package generator

import (
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/coopernurse/barrister2/pkg/parser"
)

// PythonClientServer is a plugin that generates Python HTTP server and client code from IDL
type PythonClientServer struct {
}

// NewPythonClientServer creates a new PythonClientServer plugin instance
func NewPythonClientServer() *PythonClientServer {
	return &PythonClientServer{}
}

// Name returns the plugin identifier
func (p *PythonClientServer) Name() string {
	return "python-client-server"
}

// RegisterFlags registers CLI flags for this plugin
func (p *PythonClientServer) RegisterFlags(fs *flag.FlagSet) {
	// Plugins can add their own flags here if needed.
	// Common flags like -dir are registered in main().
}

// Generate generates Python HTTP server and client code from the parsed IDL
func (p *PythonClientServer) Generate(idl *parser.IDL, fs *flag.FlagSet) error {
	// Access the -dir flag value
	dirFlag := fs.Lookup("dir")
	outputDir := ""
	if dirFlag != nil && dirFlag.Value.String() != "" {
		outputDir = dirFlag.Value.String()
	}

	// Build type registries
	structMap := make(map[string]*parser.Struct)
	enumMap := make(map[string]*parser.Enum)
	interfaceMap := make(map[string]*parser.Interface)

	for _, s := range idl.Structs {
		structMap[s.Name] = s
	}
	for _, e := range idl.Enums {
		enumMap[e.Name] = e
	}
	for _, i := range idl.Interfaces {
		interfaceMap[i.Name] = i
	}

	// Copy runtime library files
	if err := p.copyRuntimeFiles(outputDir); err != nil {
		return fmt.Errorf("failed to copy runtime files: %w", err)
	}

	// Generate idl.py
	idlCode := generateIdlPy(idl, structMap, enumMap)
	idlPath := filepath.Join(outputDir, "idl.py")
	if err := os.WriteFile(idlPath, []byte(idlCode), 0644); err != nil {
		return fmt.Errorf("failed to write idl.py: %w", err)
	}

	// Generate server.py
	serverCode := generateServerPy(idl, structMap, enumMap, interfaceMap)
	serverPath := filepath.Join(outputDir, "server.py")
	if err := os.WriteFile(serverPath, []byte(serverCode), 0644); err != nil {
		return fmt.Errorf("failed to write server.py: %w", err)
	}

	// Generate client.py
	clientCode := generateClientPy(idl, structMap, enumMap, interfaceMap)
	clientPath := filepath.Join(outputDir, "client.py")
	if err := os.WriteFile(clientPath, []byte(clientCode), 0644); err != nil {
		return fmt.Errorf("failed to write client.py: %w", err)
	}

	// Write IDL JSON document for barrister-idl RPC method
	jsonData, err := json.MarshalIndent(idl, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal IDL to JSON: %w", err)
	}
	jsonPath := filepath.Join(outputDir, "idl.json")
	if err := os.WriteFile(jsonPath, jsonData, 0644); err != nil {
		return fmt.Errorf("failed to write idl.json: %w", err)
	}

	return nil
}

// copyRuntimeFiles copies the Python runtime library files to the output directory
func (p *PythonClientServer) copyRuntimeFiles(outputDir string) error {
	runtimeDir := filepath.Join(outputDir, "barrister2")
	if err := os.MkdirAll(runtimeDir, 0755); err != nil {
		return fmt.Errorf("failed to create runtime directory: %w", err)
	}

	// Find runtime source directory relative to the binary
	// Try multiple possible locations (workspace root, or relative to binary)
	sourceDirs := []string{
		"runtimes/python/barrister2",                                  // From workspace root
		filepath.Join("..", "..", "runtimes", "python", "barrister2"), // From pkg/generator
		filepath.Join(".", "runtimes", "python", "barrister2"),        // Current dir
	}

	var sourceDir string
	for _, dir := range sourceDirs {
		if _, err := os.Stat(dir); err == nil {
			sourceDir = dir
			break
		}
	}

	if sourceDir == "" {
		return fmt.Errorf("could not find runtime source directory (tried: %v)", sourceDirs)
	}

	// Read all .py files from source directory
	entries, err := os.ReadDir(sourceDir)
	if err != nil {
		return fmt.Errorf("failed to read runtime source directory %s: %w", sourceDir, err)
	}

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}

		// Only copy .py files
		if !strings.HasSuffix(entry.Name(), ".py") {
			continue
		}

		// Read from source
		srcPath := filepath.Join(sourceDir, entry.Name())
		data, err := os.ReadFile(srcPath)
		if err != nil {
			return fmt.Errorf("failed to read runtime file %s: %w", srcPath, err)
		}

		// Write to output directory
		dstPath := filepath.Join(runtimeDir, entry.Name())
		if err := os.WriteFile(dstPath, data, 0644); err != nil {
			return fmt.Errorf("failed to write runtime file %s: %w", dstPath, err)
		}
	}

	return nil
}

// generateIdlPy generates the idl.py file with IDL-specific type definitions
func generateIdlPy(idl *parser.IDL, structMap map[string]*parser.Struct, enumMap map[string]*parser.Enum) string {
	var sb strings.Builder

	sb.WriteString("# Generated by barrister - do not edit\n\n")
	sb.WriteString("from barrister2 import (\n")
	sb.WriteString("    RPCError,\n")
	sb.WriteString("    validate_type,\n")
	sb.WriteString("    validate_struct,\n")
	sb.WriteString("    validate_enum,\n")
	sb.WriteString("    find_struct,\n")
	sb.WriteString("    find_enum,\n")
	sb.WriteString("    get_struct_fields,\n")
	sb.WriteString(")\n\n")

	// Generate IDL-specific type definitions
	sb.WriteString("# IDL-specific type definitions\n")
	sb.WriteString("ALL_STRUCTS = {\n")
	for _, s := range idl.Structs {
		sb.WriteString(fmt.Sprintf("    '%s': {\n", s.Name))
		if s.Extends != "" {
			sb.WriteString(fmt.Sprintf("        'extends': '%s',\n", s.Extends))
		}
		sb.WriteString("        'fields': [\n")
		for _, field := range s.Fields {
			sb.WriteString("            {\n")
			sb.WriteString(fmt.Sprintf("                'name': '%s',\n", field.Name))
			sb.WriteString("                'type': ")
			writeTypeDict(&sb, field.Type)
			sb.WriteString(",\n")
			if field.Optional {
				sb.WriteString("                'optional': True,\n")
			}
			sb.WriteString("            },\n")
		}
		sb.WriteString("        ],\n")
		sb.WriteString("    },\n")
	}
	sb.WriteString("}\n\n")

	sb.WriteString("ALL_ENUMS = {\n")
	for _, e := range idl.Enums {
		sb.WriteString(fmt.Sprintf("    '%s': {\n", e.Name))
		sb.WriteString("        'values': [\n")
		for _, val := range e.Values {
			sb.WriteString(fmt.Sprintf("            {'name': '%s'},\n", val.Name))
		}
		sb.WriteString("        ],\n")
		sb.WriteString("    },\n")
	}
	sb.WriteString("}\n")

	return sb.String()
}

// writeTypeDict writes a type definition as a Python dict
func writeTypeDict(sb *strings.Builder, t *parser.Type) {
	sb.WriteString("{")
	if t.IsBuiltIn() {
		fmt.Fprintf(sb, "'builtIn': '%s'", t.BuiltIn)
	} else if t.IsArray() {
		sb.WriteString("'array': ")
		writeTypeDict(sb, t.Array)
	} else if t.IsMap() {
		sb.WriteString("'mapValue': ")
		writeTypeDict(sb, t.MapValue)
	} else if t.IsUserDefined() {
		fmt.Fprintf(sb, "'userDefined': '%s'", t.UserDefined)
	}
	sb.WriteString("}")
}

// generateServerPy generates the server.py file with HTTP server and interface stubs
func generateServerPy(idl *parser.IDL, structMap map[string]*parser.Struct, enumMap map[string]*parser.Enum, interfaceMap map[string]*parser.Interface) string {
	var sb strings.Builder

	sb.WriteString("# Generated by barrister - do not edit\n\n")
	sb.WriteString("import abc\n")
	sb.WriteString("import json\n")
	sb.WriteString("import os\n")
	sb.WriteString("from http.server import HTTPServer, BaseHTTPRequestHandler\n")
	sb.WriteString("from typing import Any, Dict, List, Optional\n\n")
	sb.WriteString("from barrister2 import RPCError, validate_type\n")
	sb.WriteString("from idl import ALL_STRUCTS, ALL_ENUMS\n\n")

	// Generate interface stub classes
	for _, iface := range idl.Interfaces {
		writeInterfaceStub(&sb, iface)
	}

	// Generate BarristerServer class
	sb.WriteString("class BarristerServer:\n")
	sb.WriteString("    \"\"\"HTTP server for JSON-RPC 2.0 requests using Python's built-in http.server\"\"\"\n\n")
	sb.WriteString("    def __init__(self, host: str = 'localhost', port: int = 8080):\n")
	sb.WriteString("        self.host = host\n")
	sb.WriteString("        self.port = port\n")
	sb.WriteString("        self.handlers: Dict[str, Any] = {}\n")
	sb.WriteString("        self._server: Optional[HTTPServer] = None\n\n")

	sb.WriteString("    def register(self, interface_name: str, instance: Any) -> None:\n")
	sb.WriteString("        \"\"\"Register an interface implementation instance\"\"\"\n")
	sb.WriteString("        self.handlers[interface_name] = instance\n\n")

	// Generate handler class
	sb.WriteString("    def _create_handler_class(self):\n")
	sb.WriteString("        handlers = self.handlers\n")
	sb.WriteString("        server_instance = self\n\n")
	sb.WriteString("        class BarristerHandler(BaseHTTPRequestHandler):\n")
	sb.WriteString("            def do_POST(self):\n")
	sb.WriteString("                # Read request body\n")
	sb.WriteString("                content_length = int(self.headers.get('Content-Length', 0))\n")
	sb.WriteString("                if content_length == 0:\n")
	sb.WriteString("                    self._send_error_response(None, -32700, \"Parse error\", \"Empty request body\")\n")
	sb.WriteString("                    return\n\n")
	sb.WriteString("                body = self.rfile.read(content_length)\n")
	sb.WriteString("                \n")
	sb.WriteString("                try:\n")
	sb.WriteString("                    data = json.loads(body.decode('utf-8'))\n")
	sb.WriteString("                except (json.JSONDecodeError, UnicodeDecodeError) as e:\n")
	sb.WriteString("                    self._send_error_response(None, -32700, \"Parse error\", f\"Invalid JSON: {e}\")\n")
	sb.WriteString("                    return\n\n")
	sb.WriteString("                # Handle batch requests\n")
	sb.WriteString("                if isinstance(data, list):\n")
	sb.WriteString("                    if len(data) == 0:\n")
	sb.WriteString("                        self._send_error_response(None, -32600, \"Invalid Request\", \"Empty batch array\")\n")
	sb.WriteString("                        return\n")
	sb.WriteString("                    responses = []\n")
	sb.WriteString("                    for req in data:\n")
	sb.WriteString("                        response = server_instance.handle_request(req)\n")
	sb.WriteString("                        if response is not None:\n")
	sb.WriteString("                            responses.append(response)\n")
	sb.WriteString("                    if len(responses) == 0:\n")
	sb.WriteString("                        self._send_response(204, b'')\n")
	sb.WriteString("                    else:\n")
	sb.WriteString("                        self._send_json_response(200, responses)\n")
	sb.WriteString("                else:\n")
	sb.WriteString("                    response = server_instance.handle_request(data)\n")
	sb.WriteString("                    if response is None:\n")
	sb.WriteString("                        self._send_response(204, b'')\n")
	sb.WriteString("                    else:\n")
	sb.WriteString("                        self._send_json_response(200, response)\n\n")

	sb.WriteString("            def _send_json_response(self, status: int, data: Any) -> None:\n")
	sb.WriteString("                \"\"\"Send a JSON response\"\"\"\n")
	sb.WriteString("                response_body = json.dumps(data).encode('utf-8')\n")
	sb.WriteString("                self.send_response(status)\n")
	sb.WriteString("                self.send_header('Content-Type', 'application/json')\n")
	sb.WriteString("                self.send_header('Content-Length', str(len(response_body)))\n")
	sb.WriteString("                self.end_headers()\n")
	sb.WriteString("                self.wfile.write(response_body)\n\n")

	sb.WriteString("            def _send_response(self, status: int, body: bytes) -> None:\n")
	sb.WriteString("                \"\"\"Send a response with raw body\"\"\"\n")
	sb.WriteString("                self.send_response(status)\n")
	sb.WriteString("                if len(body) > 0:\n")
	sb.WriteString("                    self.send_header('Content-Length', str(len(body)))\n")
	sb.WriteString("                self.end_headers()\n")
	sb.WriteString("                if len(body) > 0:\n")
	sb.WriteString("                    self.wfile.write(body)\n\n")

	sb.WriteString("            def _send_error_response(self, request_id: Any, code: int, message: str, data: Any = None) -> None:\n")
	sb.WriteString("                \"\"\"Send a JSON-RPC 2.0 error response\"\"\"\n")
	sb.WriteString("                error = {'code': code, 'message': message}\n")
	sb.WriteString("                if data is not None:\n")
	sb.WriteString("                    error['data'] = data\n")
	sb.WriteString("                response = {'jsonrpc': '2.0', 'error': error, 'id': request_id}\n")
	sb.WriteString("                self._send_json_response(200, response)\n\n")

	sb.WriteString("            def log_message(self, format: str, *args: Any) -> None:\n")
	sb.WriteString("                \"\"\"Override to customize logging if needed\"\"\"\n")
	sb.WriteString("                # Suppress default logging, or customize as needed\n")
	sb.WriteString("                pass\n\n")

	sb.WriteString("        return BarristerHandler\n\n")

	sb.WriteString("    def handle_request(self, request_json: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n")
	sb.WriteString("        \"\"\"Handle a single JSON-RPC 2.0 request\"\"\"\n")
	sb.WriteString("        # Validate JSON-RPC 2.0 structure\n")
	sb.WriteString("        if not isinstance(request_json, dict):\n")
	sb.WriteString("            return self._error_response(None, -32600, \"Invalid Request\", \"Request must be an object\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        jsonrpc = request_json.get('jsonrpc')\n")
	sb.WriteString("        if jsonrpc != '2.0':\n")
	sb.WriteString("            return self._error_response(None, -32600, \"Invalid Request\", \"jsonrpc must be '2.0'\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        method = request_json.get('method')\n")
	sb.WriteString("        if not isinstance(method, str):\n")
	sb.WriteString("            return self._error_response(None, -32600, \"Invalid Request\", \"method must be a string\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        params = request_json.get('params')\n")
	sb.WriteString("        request_id = request_json.get('id')\n")
	sb.WriteString("        is_notification = 'id' not in request_json\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Special case: barrister-idl method returns the IDL JSON document\n")
	sb.WriteString("        if method == \"barrister-idl\":\n")
	sb.WriteString("            try:\n")
	sb.WriteString("                # Get the directory where server.py is located\n")
	sb.WriteString("                server_dir = os.path.dirname(os.path.abspath(__file__))\n")
	sb.WriteString("                idl_json_path = os.path.join(server_dir, \"idl.json\")\n")
	sb.WriteString("                \n")
	sb.WriteString("                with open(idl_json_path, 'r', encoding='utf-8') as f:\n")
	sb.WriteString("                    idl_doc = json.load(f)\n")
	sb.WriteString("                \n")
	sb.WriteString("                # Return success response\n")
	sb.WriteString("                if is_notification:\n")
	sb.WriteString("                    return None\n")
	sb.WriteString("                return {\n")
	sb.WriteString("                    'jsonrpc': '2.0',\n")
	sb.WriteString("                    'result': idl_doc,\n")
	sb.WriteString("                    'id': request_id\n")
	sb.WriteString("                }\n")
	sb.WriteString("            except FileNotFoundError:\n")
	sb.WriteString("                return self._error_response(request_id, -32603, \"Internal error\", \"IDL JSON file not found\")\n")
	sb.WriteString("            except json.JSONDecodeError as e:\n")
	sb.WriteString("                return self._error_response(request_id, -32603, \"Internal error\", f\"Failed to parse IDL JSON: {e}\")\n")
	sb.WriteString("            except Exception as e:\n")
	sb.WriteString("                return self._error_response(request_id, -32603, \"Internal error\", f\"Failed to load IDL JSON: {e}\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Parse method name: interface.method\n")
	sb.WriteString("        parts = method.split('.', 1)\n")
	sb.WriteString("        if len(parts) != 2:\n")
	sb.WriteString("            return self._error_response(request_id, -32601, \"Method not found\", f\"Invalid method format: {method}\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        interface_name, method_name = parts\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Find handler\n")
	sb.WriteString("        handler = self.handlers.get(interface_name)\n")
	sb.WriteString("        if handler is None:\n")
	sb.WriteString("            return self._error_response(request_id, -32601, \"Method not found\", f\"Interface '{interface_name}' not registered\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Find method on handler\n")
	sb.WriteString("        if not hasattr(handler, method_name):\n")
	sb.WriteString("            return self._error_response(request_id, -32601, \"Method not found\", f\"Method '{method_name}' not found on interface '{interface_name}'\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        method_func = getattr(handler, method_name)\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Find interface and method definition\n")
	writeInterfaceMethodLookup(&sb, idl.Interfaces)
	sb.WriteString("        \n")
	sb.WriteString("        if method_def is None:\n")
	sb.WriteString("            return self._error_response(request_id, -32601, \"Method not found\", f\"Method '{method_name}' not found in interface '{interface_name}'\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Validate params\n")
	sb.WriteString("        if params is None:\n")
	sb.WriteString("            params = []\n")
	sb.WriteString("        if not isinstance(params, list):\n")
	sb.WriteString("            return self._error_response(request_id, -32602, \"Invalid params\", \"params must be an array\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Validate param count\n")
	sb.WriteString("        expected_params = method_def.get('parameters', [])\n")
	sb.WriteString("        if len(params) != len(expected_params):\n")
	sb.WriteString("            return self._error_response(request_id, -32602, \"Invalid params\", f\"Expected {len(expected_params)} parameters, got {len(params)}\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Validate each param\n")
	sb.WriteString("        for i, (param_value, param_def) in enumerate(zip(params, expected_params)):\n")
	sb.WriteString("            try:\n")
	sb.WriteString("                validate_type(param_value, param_def['type'], ALL_STRUCTS, ALL_ENUMS, False)\n")
	sb.WriteString("            except Exception as e:\n")
	sb.WriteString("                return self._error_response(request_id, -32602, \"Invalid params\", f\"Parameter {i} ({param_def['name']}) validation failed: {e}\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Invoke handler\n")
	sb.WriteString("        try:\n")
	sb.WriteString("            result = method_func(*params)\n")
	sb.WriteString("        except RPCError as e:\n")
	sb.WriteString("            return self._error_response(request_id, e.code, e.message, e.data)\n")
	sb.WriteString("        except Exception as e:\n")
	sb.WriteString("            return self._error_response(request_id, -32603, \"Internal error\", str(e))\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Validate response\n")
	sb.WriteString("        return_type = method_def.get('returnType')\n")
	sb.WriteString("        return_optional = method_def.get('returnOptional', False)\n")
	sb.WriteString("        if return_type:\n")
	sb.WriteString("            try:\n")
	sb.WriteString("                validate_type(result, return_type, ALL_STRUCTS, ALL_ENUMS, return_optional)\n")
	sb.WriteString("            except Exception as e:\n")
	sb.WriteString("                return self._error_response(request_id, -32603, \"Internal error\", f\"Response validation failed: {e}\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Return success response\n")
	sb.WriteString("        if is_notification:\n")
	sb.WriteString("            return None\n")
	sb.WriteString("        return {\n")
	sb.WriteString("            'jsonrpc': '2.0',\n")
	sb.WriteString("            'result': result,\n")
	sb.WriteString("            'id': request_id\n")
	sb.WriteString("        }\n\n")

	sb.WriteString("    def _error_response(self, request_id: Any, code: int, message: str, data: Any = None) -> Dict[str, Any]:\n")
	sb.WriteString("        \"\"\"Create a JSON-RPC 2.0 error response\"\"\"\n")
	sb.WriteString("        error = {\n")
	sb.WriteString("            'code': code,\n")
	sb.WriteString("            'message': message\n")
	sb.WriteString("        }\n")
	sb.WriteString("        if data is not None:\n")
	sb.WriteString("            error['data'] = data\n")
	sb.WriteString("        return {\n")
	sb.WriteString("            'jsonrpc': '2.0',\n")
	sb.WriteString("            'error': error,\n")
	sb.WriteString("            'id': request_id\n")
	sb.WriteString("        }\n\n")

	sb.WriteString("    def serve_forever(self) -> None:\n")
	sb.WriteString("        \"\"\"Start the HTTP server and serve forever\"\"\"\n")
	sb.WriteString("        handler_class = self._create_handler_class()\n")
	sb.WriteString("        self._server = HTTPServer((self.host, self.port), handler_class)\n")
	sb.WriteString("        print(f\"Barrister server listening on http://{self.host}:{self.port}\")\n")
	sb.WriteString("        self._server.serve_forever()\n\n")

	sb.WriteString("    def shutdown(self) -> None:\n")
	sb.WriteString("        \"\"\"Shutdown the HTTP server\"\"\"\n")
	sb.WriteString("        if self._server:\n")
	sb.WriteString("            self._server.shutdown()\n")

	return sb.String()
}

// generateClientPy generates the client.py file with transport abstraction and client classes
func generateClientPy(idl *parser.IDL, structMap map[string]*parser.Struct, enumMap map[string]*parser.Enum, interfaceMap map[string]*parser.Interface) string {
	var sb strings.Builder

	sb.WriteString("# Generated by barrister - do not edit\n\n")
	sb.WriteString("from abc import ABC, abstractmethod\n")
	sb.WriteString("from typing import Dict, Any, Optional, List\n")
	sb.WriteString("import json\n")
	sb.WriteString("import urllib.request\n")
	sb.WriteString("import urllib.error\n")
	sb.WriteString("import uuid\n\n")
	sb.WriteString("from barrister2 import RPCError, validate_type\n")
	sb.WriteString("from idl import ALL_STRUCTS, ALL_ENUMS\n\n")

	// Generate Transport ABC
	writeTransportABC(&sb)

	// Generate HTTPTransport
	writeHTTPTransport(&sb)

	// Generate client classes for each interface
	for _, iface := range idl.Interfaces {
		writeInterfaceClient(&sb, iface, idl.Interfaces)
	}

	return sb.String()
}

// writeTransportABC generates the Transport abstract base class
func writeTransportABC(sb *strings.Builder) {
	sb.WriteString("class Transport(ABC):\n")
	sb.WriteString("    \"\"\"Abstract base class for transport implementations.\n")
	sb.WriteString("    \n")
	sb.WriteString("    Transports handle the roundtrip of sending requests to the server\n")
	sb.WriteString("    and decoding responses. Different transports can use different\n")
	sb.WriteString("    protocols (HTTP, ZeroMQ, etc.) and serialization formats (JSON, MessagePack, etc.).\n")
	sb.WriteString("    \"\"\"\n\n")
	sb.WriteString("    @abstractmethod\n")
	sb.WriteString("    def call(self, method: str, params: list) -> dict:\n")
	sb.WriteString("        \"\"\"Perform a JSON-RPC 2.0 call and return the response.\n")
	sb.WriteString("        \n")
	sb.WriteString("        Args:\n")
	sb.WriteString("            method: The method name in format 'interface.method'\n")
	sb.WriteString("            params: List of parameters to pass to the method\n")
	sb.WriteString("        \n")
	sb.WriteString("        Returns:\n")
	sb.WriteString("            dict: The JSON-RPC 2.0 response dictionary\n")
	sb.WriteString("        \n")
	sb.WriteString("        Raises:\n")
	sb.WriteString("            RPCError: If the JSON-RPC call returns an error\n")
	sb.WriteString("            Exception: For transport-level errors (network, etc.)\n")
	sb.WriteString("        \"\"\"\n")
	sb.WriteString("        pass\n\n\n")
}

// writeHTTPTransport generates the HTTPTransport class
func writeHTTPTransport(sb *strings.Builder) {
	sb.WriteString("class HTTPTransport(Transport):\n")
	sb.WriteString("    \"\"\"HTTP transport implementation using JSON-RPC 2.0 over HTTP.\n")
	sb.WriteString("    \n")
	sb.WriteString("    Uses Python's standard library urllib.request for HTTP requests.\n")
	sb.WriteString("    Supports configurable headers for authentication and other purposes.\n")
	sb.WriteString("    \"\"\"\n\n")
	sb.WriteString("    def __init__(self, base_url: str, headers: Optional[Dict[str, str]] = None):\n")
	sb.WriteString("        \"\"\"Initialize HTTP transport.\n")
	sb.WriteString("        \n")
	sb.WriteString("        Args:\n")
	sb.WriteString("            base_url: Base URL of the server (e.g., 'http://localhost:8080')\n")
	sb.WriteString("            headers: Optional dictionary of HTTP headers to include with each request\n")
	sb.WriteString("        \"\"\"\n")
	sb.WriteString("        self.base_url = base_url.rstrip('/')\n")
	sb.WriteString("        self.headers = headers.copy() if headers else {}\n\n")
	sb.WriteString("    def call(self, method: str, params: list) -> dict:\n")
	sb.WriteString("        \"\"\"Perform a JSON-RPC 2.0 call over HTTP.\n")
	sb.WriteString("        \n")
	sb.WriteString("        Args:\n")
	sb.WriteString("            method: The method name in format 'interface.method'\n")
	sb.WriteString("            params: List of parameters to pass to the method\n")
	sb.WriteString("        \n")
	sb.WriteString("        Returns:\n")
	sb.WriteString("            dict: The JSON-RPC 2.0 response dictionary\n")
	sb.WriteString("        \n")
	sb.WriteString("        Raises:\n")
	sb.WriteString("            RPCError: If the JSON-RPC call returns an error\n")
	sb.WriteString("            urllib.error.HTTPError: For HTTP errors\n")
	sb.WriteString("            urllib.error.URLError: For network errors\n")
	sb.WriteString("        \"\"\"\n")
	sb.WriteString("        # Generate request ID\n")
	sb.WriteString("        request_id = str(uuid.uuid4())\n\n")
	sb.WriteString("        # Build JSON-RPC 2.0 request\n")
	sb.WriteString("        request_data = {\n")
	sb.WriteString("            'jsonrpc': '2.0',\n")
	sb.WriteString("            'method': method,\n")
	sb.WriteString("            'params': params,\n")
	sb.WriteString("            'id': request_id\n")
	sb.WriteString("        }\n\n")
	sb.WriteString("        # Serialize to JSON\n")
	sb.WriteString("        json_data = json.dumps(request_data).encode('utf-8')\n\n")
	sb.WriteString("        # Prepare request\n")
	sb.WriteString("        req = urllib.request.Request(self.base_url, data=json_data, method='POST')\n")
	sb.WriteString("        req.add_header('Content-Type', 'application/json')\n")
	sb.WriteString("        req.add_header('Content-Length', str(len(json_data)))\n\n")
	sb.WriteString("        # Add custom headers\n")
	sb.WriteString("        for key, value in self.headers.items():\n")
	sb.WriteString("            req.add_header(key, value)\n\n")
	sb.WriteString("        try:\n")
	sb.WriteString("            # Send request\n")
	sb.WriteString("            with urllib.request.urlopen(req) as response:\n")
	sb.WriteString("                response_body = response.read().decode('utf-8')\n")
	sb.WriteString("                response_data = json.loads(response_body)\n\n")
	sb.WriteString("                # Check for JSON-RPC error\n")
	sb.WriteString("                if 'error' in response_data:\n")
	sb.WriteString("                    error = response_data['error']\n")
	sb.WriteString("                    code = error.get('code', -32603)\n")
	sb.WriteString("                    message = error.get('message', 'Internal error')\n")
	sb.WriteString("                    data = error.get('data')\n")
	sb.WriteString("                    raise RPCError(code, message, data)\n\n")
	sb.WriteString("                # Return response\n")
	sb.WriteString("                return response_data\n\n")
	sb.WriteString("        except urllib.error.HTTPError as e:\n")
	sb.WriteString("            # Try to parse error response as JSON-RPC\n")
	sb.WriteString("            try:\n")
	sb.WriteString("                error_body = e.read().decode('utf-8')\n")
	sb.WriteString("                error_data = json.loads(error_body)\n")
	sb.WriteString("                if 'error' in error_data:\n")
	sb.WriteString("                    error = error_data['error']\n")
	sb.WriteString("                    code = error.get('code', -32603)\n")
	sb.WriteString("                    message = error.get('message', 'Internal error')\n")
	sb.WriteString("                    data = error.get('data')\n")
	sb.WriteString("                    raise RPCError(code, message, data)\n")
	sb.WriteString("            except (json.JSONDecodeError, UnicodeDecodeError):\n")
	sb.WriteString("                pass\n")
	sb.WriteString("            # If not JSON-RPC error, raise HTTP error\n")
	sb.WriteString("            raise RPCError(-32603, f\"HTTP error: {e.code} {e.reason}\", None)\n")
	sb.WriteString("        except urllib.error.URLError as e:\n")
	sb.WriteString("            raise RPCError(-32603, f\"Network error: {e.reason}\", None)\n\n\n")
}

// writeInterfaceClient generates a client class for an interface
func writeInterfaceClient(sb *strings.Builder, iface *parser.Interface, allInterfaces []*parser.Interface) {
	// Write interface comment if present
	if iface.Comment != "" {
		lines := strings.Split(strings.TrimSpace(iface.Comment), "\n")
		for _, line := range lines {
			fmt.Fprintf(sb, "# %s\n", line)
		}
	}

	clientClassName := iface.Name + "Client"
	fmt.Fprintf(sb, "class %s:\n", clientClassName)
	if iface.Comment != "" {
		fmt.Fprintf(sb, "    \"\"\"Client for %s interface.\n\n", iface.Name)
		fmt.Fprintf(sb, "    %s\n", strings.TrimSpace(iface.Comment))
		sb.WriteString("    \"\"\"\n\n")
	} else {
		fmt.Fprintf(sb, "    \"\"\"Client for %s interface.\"\"\"\n\n", iface.Name)
	}

	sb.WriteString("    def __init__(self, transport: Transport):\n")
	sb.WriteString("        \"\"\"Initialize client with a transport.\n\n")
	sb.WriteString("        Args:\n")
	sb.WriteString("            transport: Transport instance to use for RPC calls\n")
	sb.WriteString("        \"\"\"\n")
	sb.WriteString("        self.transport = transport\n\n")

	// Generate method lookup for this interface
	sb.WriteString("        # Method definitions for validation\n")
	sb.WriteString("        self._method_defs = {\n")
	for _, method := range iface.Methods {
		fmt.Fprintf(sb, "            '%s': {\n", method.Name)
		sb.WriteString("                'parameters': [\n")
		for _, param := range method.Parameters {
			sb.WriteString("                    {\n")
			fmt.Fprintf(sb, "                        'name': '%s',\n", param.Name)
			sb.WriteString("                        'type': ")
			writeTypeDict(sb, param.Type)
			sb.WriteString(",\n")
			sb.WriteString("                    },\n")
		}
		sb.WriteString("                ],\n")
		sb.WriteString("                'returnType': ")
		writeTypeDict(sb, method.ReturnType)
		sb.WriteString(",\n")
		sb.WriteString("                'returnOptional': False,\n")
		sb.WriteString("            },\n")
	}
	sb.WriteString("        }\n\n")

	// Generate methods
	for _, method := range iface.Methods {
		writeClientMethod(sb, iface, method)
	}
	sb.WriteString("\n")
}

// writeClientMethod generates a method implementation for a client class
func writeClientMethod(sb *strings.Builder, iface *parser.Interface, method *parser.Method) {
	// Method signature
	fmt.Fprintf(sb, "    def %s(self", method.Name)
	for _, param := range method.Parameters {
		fmt.Fprintf(sb, ", %s", param.Name)
	}
	sb.WriteString("):\n")

	// Method docstring
	if len(method.Parameters) > 0 {
		sb.WriteString("        \"\"\"Call ")
		fmt.Fprintf(sb, "%s.%s", iface.Name, method.Name)
		sb.WriteString(".\n\n")
		sb.WriteString("        Args:\n")
		for _, param := range method.Parameters {
			fmt.Fprintf(sb, "            %s: Parameter %s\n", param.Name, param.Name)
		}
		sb.WriteString("\n        Returns:\n")
		sb.WriteString("            The method return value\n\n")
		sb.WriteString("        Raises:\n")
		sb.WriteString("            RPCError: If the RPC call fails\n")
		sb.WriteString("        \"\"\"\n")
	} else {
		sb.WriteString("        \"\"\"Call ")
		fmt.Fprintf(sb, "%s.%s", iface.Name, method.Name)
		sb.WriteString(".\n\n")
		sb.WriteString("        Returns:\n")
		sb.WriteString("            The method return value\n\n")
		sb.WriteString("        Raises:\n")
		sb.WriteString("            RPCError: If the RPC call fails\n")
		sb.WriteString("        \"\"\"\n")
	}

	// Get method definition
	fmt.Fprintf(sb, "        method_def = self._method_defs['%s']\n", method.Name)
	sb.WriteString("        params = [\n")
	for _, param := range method.Parameters {
		fmt.Fprintf(sb, "            %s,\n", param.Name)
	}
	sb.WriteString("        ]\n\n")

	// Validate parameters
	sb.WriteString("        # Validate parameters\n")
	sb.WriteString("        expected_params = method_def.get('parameters', [])\n")
	sb.WriteString("        for i, (param_value, param_def) in enumerate(zip(params, expected_params)):\n")
	sb.WriteString("            try:\n")
	sb.WriteString("                validate_type(param_value, param_def['type'], ALL_STRUCTS, ALL_ENUMS, False)\n")
	sb.WriteString("            except Exception as e:\n")
	sb.WriteString("                raise ValueError(f\"Parameter {i} ({param_def['name']}) validation failed: {e}\")\n\n")

	// Call transport
	fmt.Fprintf(sb, "        # Call transport\n")
	fmt.Fprintf(sb, "        method_name = '%s.%s'\n", iface.Name, method.Name)
	sb.WriteString("        response = self.transport.call(method_name, params)\n\n")

	// Extract result
	sb.WriteString("        # Extract result from JSON-RPC response\n")
	sb.WriteString("        if 'error' in response:\n")
	sb.WriteString("            error = response['error']\n")
	sb.WriteString("            code = error.get('code', -32603)\n")
	sb.WriteString("            message = error.get('message', 'Internal error')\n")
	sb.WriteString("            data = error.get('data')\n")
	sb.WriteString("            raise RPCError(code, message, data)\n\n")
	sb.WriteString("        result = response.get('result')\n\n")

	// Validate result
	sb.WriteString("        # Validate result\n")
	sb.WriteString("        return_type = method_def.get('returnType')\n")
	sb.WriteString("        return_optional = method_def.get('returnOptional', False)\n")
	sb.WriteString("        if return_type:\n")
	sb.WriteString("            try:\n")
	sb.WriteString("                validate_type(result, return_type, ALL_STRUCTS, ALL_ENUMS, return_optional)\n")
	sb.WriteString("            except Exception as e:\n")
	sb.WriteString("                raise ValueError(f\"Response validation failed: {e}\")\n\n")

	// Return result
	sb.WriteString("        return result\n\n")
}

// writeInterfaceStub writes an abstract base class for an interface
func writeInterfaceStub(sb *strings.Builder, iface *parser.Interface) {
	if iface.Comment != "" {
		lines := strings.Split(strings.TrimSpace(iface.Comment), "\n")
		for _, line := range lines {
			fmt.Fprintf(sb, "# %s\n", line)
		}
	}
	fmt.Fprintf(sb, "class %s(abc.ABC):\n", iface.Name)
	if iface.Comment != "" {
		fmt.Fprintf(sb, "    \"\"\"%s\"\"\"\n", strings.TrimSpace(iface.Comment))
	}
	sb.WriteString("\n")

	for _, method := range iface.Methods {
		sb.WriteString("    @abc.abstractmethod\n")
		fmt.Fprintf(sb, "    def %s(self", method.Name)
		for _, param := range method.Parameters {
			fmt.Fprintf(sb, ", %s", param.Name)
		}
		sb.WriteString("):\n")
		sb.WriteString("        pass\n\n")
	}
	sb.WriteString("\n")
}

// writeInterfaceMethodLookup generates code to find method definitions
func writeInterfaceMethodLookup(sb *strings.Builder, interfaces []*parser.Interface) {
	sb.WriteString("        method_def = None\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Interface method lookup\n")
	for i, iface := range interfaces {
		if i == 0 {
			fmt.Fprintf(sb, "        if interface_name == '%s':\n", iface.Name)
		} else {
			fmt.Fprintf(sb, "        elif interface_name == '%s':\n", iface.Name)
		}
		sb.WriteString("            interface_methods = {\n")
		for _, method := range iface.Methods {
			fmt.Fprintf(sb, "                '%s': {\n", method.Name)
			sb.WriteString("                    'parameters': [\n")
			for _, param := range method.Parameters {
				sb.WriteString("                        {\n")
				fmt.Fprintf(sb, "                            'name': '%s',\n", param.Name)
				sb.WriteString("                            'type': ")
				writeTypeDict(sb, param.Type)
				sb.WriteString(",\n")
				sb.WriteString("                        },\n")
			}
			sb.WriteString("                    ],\n")
			sb.WriteString("                    'returnType': ")
			writeTypeDict(sb, method.ReturnType)
			sb.WriteString(",\n")
			sb.WriteString("                    'returnOptional': False,\n")
			sb.WriteString("                },\n")
		}
		sb.WriteString("            }\n")
		sb.WriteString("            method_def = interface_methods.get(method_name)\n")
	}
	sb.WriteString("\n")
}

