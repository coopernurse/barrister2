package generator

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/coopernurse/barrister2/pkg/parser"
)

// PythonFlaskServer is a plugin that generates Python Flask server code from IDL
type PythonFlaskServer struct {
}

// NewPythonFlaskServer creates a new PythonFlaskServer plugin instance
func NewPythonFlaskServer() *PythonFlaskServer {
	return &PythonFlaskServer{}
}

// Name returns the plugin identifier
func (p *PythonFlaskServer) Name() string {
	return "python-flask-server"
}

// RegisterFlags registers CLI flags for this plugin
func (p *PythonFlaskServer) RegisterFlags(fs *flag.FlagSet) {
	// Plugins can add their own flags here if needed.
	// Common flags like -dir are registered in main().
}

// Generate generates Python Flask server code from the parsed IDL
func (p *PythonFlaskServer) Generate(idl *parser.IDL, fs *flag.FlagSet) error {
	// Access the -dir flag value
	dirFlag := fs.Lookup("dir")
	outputDir := ""
	if dirFlag != nil && dirFlag.Value.String() != "" {
		outputDir = dirFlag.Value.String()
	}

	// Build type registries
	structMap := make(map[string]*parser.Struct)
	enumMap := make(map[string]*parser.Enum)
	interfaceMap := make(map[string]*parser.Interface)

	for _, s := range idl.Structs {
		structMap[s.Name] = s
	}
	for _, e := range idl.Enums {
		enumMap[e.Name] = e
	}
	for _, i := range idl.Interfaces {
		interfaceMap[i.Name] = i
	}

	// Copy runtime library files
	if err := p.copyRuntimeFiles(outputDir); err != nil {
		return fmt.Errorf("failed to copy runtime files: %w", err)
	}

	// Generate idl.py
	idlCode := generateIdlPy(idl, structMap, enumMap)
	idlPath := filepath.Join(outputDir, "idl.py")
	if err := os.WriteFile(idlPath, []byte(idlCode), 0644); err != nil {
		return fmt.Errorf("failed to write idl.py: %w", err)
	}

	// Generate server.py
	serverCode := generateServerPy(idl, structMap, enumMap, interfaceMap)
	serverPath := filepath.Join(outputDir, "server.py")
	if err := os.WriteFile(serverPath, []byte(serverCode), 0644); err != nil {
		return fmt.Errorf("failed to write server.py: %w", err)
	}

	return nil
}

// copyRuntimeFiles copies the Python runtime library files to the output directory
func (p *PythonFlaskServer) copyRuntimeFiles(outputDir string) error {
	runtimeDir := filepath.Join(outputDir, "barrister2")
	if err := os.MkdirAll(runtimeDir, 0755); err != nil {
		return fmt.Errorf("failed to create runtime directory: %w", err)
	}

	// Find runtime source directory relative to the binary
	// Try multiple possible locations (workspace root, or relative to binary)
	sourceDirs := []string{
		"runtimes/python/barrister2",                                  // From workspace root
		filepath.Join("..", "..", "runtimes", "python", "barrister2"), // From pkg/generator
		filepath.Join(".", "runtimes", "python", "barrister2"),        // Current dir
	}

	var sourceDir string
	for _, dir := range sourceDirs {
		if _, err := os.Stat(dir); err == nil {
			sourceDir = dir
			break
		}
	}

	if sourceDir == "" {
		return fmt.Errorf("could not find runtime source directory (tried: %v)", sourceDirs)
	}

	// Read all .py files from source directory
	entries, err := os.ReadDir(sourceDir)
	if err != nil {
		return fmt.Errorf("failed to read runtime source directory %s: %w", sourceDir, err)
	}

	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}

		// Only copy .py files
		if !strings.HasSuffix(entry.Name(), ".py") {
			continue
		}

		// Read from source
		srcPath := filepath.Join(sourceDir, entry.Name())
		data, err := os.ReadFile(srcPath)
		if err != nil {
			return fmt.Errorf("failed to read runtime file %s: %w", srcPath, err)
		}

		// Write to output directory
		dstPath := filepath.Join(runtimeDir, entry.Name())
		if err := os.WriteFile(dstPath, data, 0644); err != nil {
			return fmt.Errorf("failed to write runtime file %s: %w", dstPath, err)
		}
	}

	return nil
}

// generateIdlPy generates the idl.py file with IDL-specific type definitions
func generateIdlPy(idl *parser.IDL, structMap map[string]*parser.Struct, enumMap map[string]*parser.Enum) string {
	var sb strings.Builder

	sb.WriteString("# Generated by barrister - do not edit\n\n")
	sb.WriteString("from barrister2 import (\n")
	sb.WriteString("    RPCError,\n")
	sb.WriteString("    validate_type,\n")
	sb.WriteString("    validate_struct,\n")
	sb.WriteString("    validate_enum,\n")
	sb.WriteString("    find_struct,\n")
	sb.WriteString("    find_enum,\n")
	sb.WriteString("    get_struct_fields,\n")
	sb.WriteString(")\n\n")

	// Generate IDL-specific type definitions
	sb.WriteString("# IDL-specific type definitions\n")
	sb.WriteString("ALL_STRUCTS = {\n")
	for _, s := range idl.Structs {
		sb.WriteString(fmt.Sprintf("    '%s': {\n", s.Name))
		if s.Extends != "" {
			sb.WriteString(fmt.Sprintf("        'extends': '%s',\n", s.Extends))
		}
		sb.WriteString("        'fields': [\n")
		for _, field := range s.Fields {
			sb.WriteString("            {\n")
			sb.WriteString(fmt.Sprintf("                'name': '%s',\n", field.Name))
			sb.WriteString("                'type': ")
			writeTypeDict(&sb, field.Type)
			sb.WriteString(",\n")
			if field.Optional {
				sb.WriteString("                'optional': True,\n")
			}
			sb.WriteString("            },\n")
		}
		sb.WriteString("        ],\n")
		sb.WriteString("    },\n")
	}
	sb.WriteString("}\n\n")

	sb.WriteString("ALL_ENUMS = {\n")
	for _, e := range idl.Enums {
		sb.WriteString(fmt.Sprintf("    '%s': {\n", e.Name))
		sb.WriteString("        'values': [\n")
		for _, val := range e.Values {
			sb.WriteString(fmt.Sprintf("            {'name': '%s'},\n", val.Name))
		}
		sb.WriteString("        ],\n")
		sb.WriteString("    },\n")
	}
	sb.WriteString("}\n")

	return sb.String()
}

// writeTypeDict writes a type definition as a Python dict
func writeTypeDict(sb *strings.Builder, t *parser.Type) {
	sb.WriteString("{")
	if t.IsBuiltIn() {
		fmt.Fprintf(sb, "'builtIn': '%s'", t.BuiltIn)
	} else if t.IsArray() {
		sb.WriteString("'array': ")
		writeTypeDict(sb, t.Array)
	} else if t.IsMap() {
		sb.WriteString("'mapValue': ")
		writeTypeDict(sb, t.MapValue)
	} else if t.IsUserDefined() {
		fmt.Fprintf(sb, "'userDefined': '%s'", t.UserDefined)
	}
	sb.WriteString("}")
}

// generateServerPy generates the server.py file with Flask server and interface stubs
func generateServerPy(idl *parser.IDL, structMap map[string]*parser.Struct, enumMap map[string]*parser.Enum, interfaceMap map[string]*parser.Interface) string {
	var sb strings.Builder

	sb.WriteString("# Generated by barrister - do not edit\n\n")
	sb.WriteString("import abc\n")
	sb.WriteString("import json\n")
	sb.WriteString("from typing import Any, Dict, List, Optional\n\n")
	sb.WriteString("from flask import Flask, request, jsonify\n")
	sb.WriteString("from barrister2 import RPCError, validate_type\n")
	sb.WriteString("from idl import ALL_STRUCTS, ALL_ENUMS\n\n")

	// Generate interface stub classes
	for _, iface := range idl.Interfaces {
		writeInterfaceStub(&sb, iface)
	}

	// Generate BarristerServer class
	sb.WriteString("class BarristerServer:\n")
	sb.WriteString("    \"\"\"Flask server for JSON-RPC 2.0 requests\"\"\"\n\n")
	sb.WriteString("    def __init__(self):\n")
	sb.WriteString("        self.app = Flask(__name__)\n")
	sb.WriteString("        self.handlers: Dict[str, Any] = {}\n")
	sb.WriteString("        self._setup_routes()\n\n")

	sb.WriteString("    def register(self, interface_name: str, instance: Any) -> None:\n")
	sb.WriteString("        \"\"\"Register an interface implementation instance\"\"\"\n")
	sb.WriteString("        self.handlers[interface_name] = instance\n\n")

	sb.WriteString("    def _setup_routes(self) -> None:\n")
	sb.WriteString("        @self.app.route('/', methods=['POST'])\n")
	sb.WriteString("        def handle_post():\n")
	sb.WriteString("            try:\n")
	sb.WriteString("                data = request.get_json()\n")
	sb.WriteString("                if data is None:\n")
	sb.WriteString("                    return jsonify(self._error_response(None, -32700, \"Parse error\", \"Invalid JSON\"))\n")
	sb.WriteString("                \n")
	sb.WriteString("                # Handle batch requests\n")
	sb.WriteString("                if isinstance(data, list):\n")
	sb.WriteString("                    if len(data) == 0:\n")
	sb.WriteString("                        return jsonify(self._error_response(None, -32600, \"Invalid Request\", \"Empty batch array\"))\n")
	sb.WriteString("                    responses = []\n")
	sb.WriteString("                    for req in data:\n")
	sb.WriteString("                        response = self.handle_request(req)\n")
	sb.WriteString("                        if response is not None:\n")
	sb.WriteString("                            responses.append(response)\n")
	sb.WriteString("                    if len(responses) == 0:\n")
	sb.WriteString("                        return '', 204  # No content for all notifications\n")
	sb.WriteString("                    return jsonify(responses)\n")
	sb.WriteString("                else:\n")
	sb.WriteString("                    response = self.handle_request(data)\n")
	sb.WriteString("                    if response is None:\n")
	sb.WriteString("                        return '', 204  # Notification\n")
	sb.WriteString("                    return jsonify(response)\n")
	sb.WriteString("            except Exception as e:\n")
	sb.WriteString("                return jsonify(self._error_response(None, -32603, \"Internal error\", str(e)))\n\n")

	sb.WriteString("    def handle_request(self, request_json: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n")
	sb.WriteString("        \"\"\"Handle a single JSON-RPC 2.0 request\"\"\"\n")
	sb.WriteString("        # Validate JSON-RPC 2.0 structure\n")
	sb.WriteString("        if not isinstance(request_json, dict):\n")
	sb.WriteString("            return self._error_response(None, -32600, \"Invalid Request\", \"Request must be an object\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        jsonrpc = request_json.get('jsonrpc')\n")
	sb.WriteString("        if jsonrpc != '2.0':\n")
	sb.WriteString("            return self._error_response(None, -32600, \"Invalid Request\", \"jsonrpc must be '2.0'\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        method = request_json.get('method')\n")
	sb.WriteString("        if not isinstance(method, str):\n")
	sb.WriteString("            return self._error_response(None, -32600, \"Invalid Request\", \"method must be a string\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        params = request_json.get('params')\n")
	sb.WriteString("        request_id = request_json.get('id')\n")
	sb.WriteString("        is_notification = 'id' not in request_json\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Parse method name: interface.method\n")
	sb.WriteString("        parts = method.split('.', 1)\n")
	sb.WriteString("        if len(parts) != 2:\n")
	sb.WriteString("            return self._error_response(request_id, -32601, \"Method not found\", f\"Invalid method format: {method}\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        interface_name, method_name = parts\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Find handler\n")
	sb.WriteString("        handler = self.handlers.get(interface_name)\n")
	sb.WriteString("        if handler is None:\n")
	sb.WriteString("            return self._error_response(request_id, -32601, \"Method not found\", f\"Interface '{interface_name}' not registered\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Find method on handler\n")
	sb.WriteString("        if not hasattr(handler, method_name):\n")
	sb.WriteString("            return self._error_response(request_id, -32601, \"Method not found\", f\"Method '{method_name}' not found on interface '{interface_name}'\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        method_func = getattr(handler, method_name)\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Find interface and method definition\n")
	writeInterfaceMethodLookup(&sb, idl.Interfaces)
	sb.WriteString("        \n")
	sb.WriteString("        if method_def is None:\n")
	sb.WriteString("            return self._error_response(request_id, -32601, \"Method not found\", f\"Method '{method_name}' not found in interface '{interface_name}'\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Validate params\n")
	sb.WriteString("        if params is None:\n")
	sb.WriteString("            params = []\n")
	sb.WriteString("        if not isinstance(params, list):\n")
	sb.WriteString("            return self._error_response(request_id, -32602, \"Invalid params\", \"params must be an array\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Validate param count\n")
	sb.WriteString("        expected_params = method_def.get('parameters', [])\n")
	sb.WriteString("        if len(params) != len(expected_params):\n")
	sb.WriteString("            return self._error_response(request_id, -32602, \"Invalid params\", f\"Expected {len(expected_params)} parameters, got {len(params)}\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Validate each param\n")
	sb.WriteString("        for i, (param_value, param_def) in enumerate(zip(params, expected_params)):\n")
	sb.WriteString("            try:\n")
	sb.WriteString("                validate_type(param_value, param_def['type'], ALL_STRUCTS, ALL_ENUMS, False)\n")
	sb.WriteString("            except Exception as e:\n")
	sb.WriteString("                return self._error_response(request_id, -32602, \"Invalid params\", f\"Parameter {i} ({param_def['name']}) validation failed: {e}\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Invoke handler\n")
	sb.WriteString("        try:\n")
	sb.WriteString("            result = method_func(*params)\n")
	sb.WriteString("        except RPCError as e:\n")
	sb.WriteString("            return self._error_response(request_id, e.code, e.message, e.data)\n")
	sb.WriteString("        except Exception as e:\n")
	sb.WriteString("            return self._error_response(request_id, -32603, \"Internal error\", str(e))\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Validate response\n")
	sb.WriteString("        return_type = method_def.get('returnType')\n")
	sb.WriteString("        return_optional = method_def.get('returnOptional', False)\n")
	sb.WriteString("        if return_type:\n")
	sb.WriteString("            try:\n")
	sb.WriteString("                validate_type(result, return_type, ALL_STRUCTS, ALL_ENUMS, return_optional)\n")
	sb.WriteString("            except Exception as e:\n")
	sb.WriteString("                return self._error_response(request_id, -32603, \"Internal error\", f\"Response validation failed: {e}\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Return success response\n")
	sb.WriteString("        if is_notification:\n")
	sb.WriteString("            return None\n")
	sb.WriteString("        return {\n")
	sb.WriteString("            'jsonrpc': '2.0',\n")
	sb.WriteString("            'result': result,\n")
	sb.WriteString("            'id': request_id\n")
	sb.WriteString("        }\n\n")

	sb.WriteString("    def _error_response(self, request_id: Any, code: int, message: str, data: Any = None) -> Dict[str, Any]:\n")
	sb.WriteString("        \"\"\"Create a JSON-RPC 2.0 error response\"\"\"\n")
	sb.WriteString("        error = {\n")
	sb.WriteString("            'code': code,\n")
	sb.WriteString("            'message': message\n")
	sb.WriteString("        }\n")
	sb.WriteString("        if data is not None:\n")
	sb.WriteString("            error['data'] = data\n")
	sb.WriteString("        return {\n")
	sb.WriteString("            'jsonrpc': '2.0',\n")
	sb.WriteString("            'error': error,\n")
	sb.WriteString("            'id': request_id\n")
	sb.WriteString("        }\n")

	return sb.String()
}

// writeInterfaceStub writes an abstract base class for an interface
func writeInterfaceStub(sb *strings.Builder, iface *parser.Interface) {
	if iface.Comment != "" {
		lines := strings.Split(strings.TrimSpace(iface.Comment), "\n")
		for _, line := range lines {
			fmt.Fprintf(sb, "# %s\n", line)
		}
	}
	fmt.Fprintf(sb, "class %s(abc.ABC):\n", iface.Name)
	if iface.Comment != "" {
		fmt.Fprintf(sb, "    \"\"\"%s\"\"\"\n", strings.TrimSpace(iface.Comment))
	}
	sb.WriteString("\n")

	for _, method := range iface.Methods {
		sb.WriteString("    @abc.abstractmethod\n")
		fmt.Fprintf(sb, "    def %s(self", method.Name)
		for _, param := range method.Parameters {
			fmt.Fprintf(sb, ", %s", param.Name)
		}
		sb.WriteString("):\n")
		sb.WriteString("        pass\n\n")
	}
	sb.WriteString("\n")
}

// writeInterfaceMethodLookup generates code to find method definitions
func writeInterfaceMethodLookup(sb *strings.Builder, interfaces []*parser.Interface) {
	sb.WriteString("        method_def = None\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Interface method lookup\n")
	for i, iface := range interfaces {
		if i == 0 {
			fmt.Fprintf(sb, "        if interface_name == '%s':\n", iface.Name)
		} else {
			fmt.Fprintf(sb, "        elif interface_name == '%s':\n", iface.Name)
		}
		sb.WriteString("            interface_methods = {\n")
		for _, method := range iface.Methods {
			fmt.Fprintf(sb, "                '%s': {\n", method.Name)
			sb.WriteString("                    'parameters': [\n")
			for _, param := range method.Parameters {
				sb.WriteString("                        {\n")
				fmt.Fprintf(sb, "                            'name': '%s',\n", param.Name)
				sb.WriteString("                            'type': ")
				writeTypeDict(sb, param.Type)
				sb.WriteString(",\n")
				sb.WriteString("                        },\n")
			}
			sb.WriteString("                    ],\n")
			sb.WriteString("                    'returnType': ")
			writeTypeDict(sb, method.ReturnType)
			sb.WriteString(",\n")
			sb.WriteString("                    'returnOptional': False,\n")
			sb.WriteString("                },\n")
		}
		sb.WriteString("            }\n")
		sb.WriteString("            method_def = interface_methods.get(method_name)\n")
	}
	sb.WriteString("\n")
}
