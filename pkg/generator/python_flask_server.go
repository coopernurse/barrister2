package generator

import (
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/coopernurse/barrister2/pkg/parser"
)

// PythonFlaskServer is a plugin that generates Python Flask server code from IDL
type PythonFlaskServer struct {
}

// NewPythonFlaskServer creates a new PythonFlaskServer plugin instance
func NewPythonFlaskServer() *PythonFlaskServer {
	return &PythonFlaskServer{}
}

// Name returns the plugin identifier
func (p *PythonFlaskServer) Name() string {
	return "python-flask-server"
}

// RegisterFlags registers CLI flags for this plugin
func (p *PythonFlaskServer) RegisterFlags(fs *flag.FlagSet) {
	// Plugins can add their own flags here if needed.
	// Common flags like -dir are registered in main().
}

// Generate generates Python Flask server code from the parsed IDL
func (p *PythonFlaskServer) Generate(idl *parser.IDL, fs *flag.FlagSet) error {
	// Access the -dir flag value
	dirFlag := fs.Lookup("dir")
	outputDir := ""
	if dirFlag != nil && dirFlag.Value.String() != "" {
		outputDir = dirFlag.Value.String()
	}

	// Build type registries
	structMap := make(map[string]*parser.Struct)
	enumMap := make(map[string]*parser.Enum)
	interfaceMap := make(map[string]*parser.Interface)

	for _, s := range idl.Structs {
		structMap[s.Name] = s
	}
	for _, e := range idl.Enums {
		enumMap[e.Name] = e
	}
	for _, i := range idl.Interfaces {
		interfaceMap[i.Name] = i
	}

	// Generate barrister.py
	barristerCode := generateBarristerPy(idl, structMap, enumMap)
	barristerPath := filepath.Join(outputDir, "barrister.py")
	if err := os.WriteFile(barristerPath, []byte(barristerCode), 0644); err != nil {
		return fmt.Errorf("failed to write barrister.py: %w", err)
	}

	// Generate server.py
	serverCode := generateServerPy(idl, structMap, enumMap, interfaceMap)
	serverPath := filepath.Join(outputDir, "server.py")
	if err := os.WriteFile(serverPath, []byte(serverCode), 0644); err != nil {
		return fmt.Errorf("failed to write server.py: %w", err)
	}

	return nil
}

// generateBarristerPy generates the barrister.py file with validation functions
func generateBarristerPy(idl *parser.IDL, structMap map[string]*parser.Struct, enumMap map[string]*parser.Enum) string {
	var sb strings.Builder

	sb.WriteString("# Generated by barrister - do not edit\n\n")
	sb.WriteString("from typing import Any, Callable, Dict, List, Optional\n\n")

	// RPCError class
	sb.WriteString("class RPCError(Exception):\n")
	sb.WriteString("    \"\"\"Exception class for JSON-RPC errors\"\"\"\n")
	sb.WriteString("    def __init__(self, code: int, message: str, data: Any = None):\n")
	sb.WriteString("        self.code = code\n")
	sb.WriteString("        self.message = message\n")
	sb.WriteString("        self.data = data\n")
	sb.WriteString("        super().__init__(f\"RPCError {code}: {message}\")\n\n")

	// Helper functions
	sb.WriteString("def find_struct(struct_name: str, all_structs: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n")
	sb.WriteString("    \"\"\"Find a struct definition by name\"\"\"\n")
	sb.WriteString("    return all_structs.get(struct_name)\n\n")

	sb.WriteString("def find_enum(enum_name: str, all_enums: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n")
	sb.WriteString("    \"\"\"Find an enum definition by name\"\"\"\n")
	sb.WriteString("    return all_enums.get(enum_name)\n\n")

	// Struct field resolution with extends
	sb.WriteString("def get_struct_fields(struct_name: str, all_structs: Dict[str, Any]) -> List[Dict[str, Any]]:\n")
	sb.WriteString("    \"\"\"Recursively resolve struct extends to return all fields (parent + child)\"\"\"\n")
	sb.WriteString("    struct_def = find_struct(struct_name, all_structs)\n")
	sb.WriteString("    if not struct_def:\n")
	sb.WriteString("        return []\n")
	sb.WriteString("    \n")
	sb.WriteString("    fields = []\n")
	sb.WriteString("    \n")
	sb.WriteString("    # Get parent fields first\n")
	sb.WriteString("    if struct_def.get('extends'):\n")
	sb.WriteString("        parent_fields = get_struct_fields(struct_def['extends'], all_structs)\n")
	sb.WriteString("        fields.extend(parent_fields)\n")
	sb.WriteString("    \n")
	sb.WriteString("    # Add child fields (override parent if name conflict)\n")
	sb.WriteString("    field_names = {f['name'] for f in fields}\n")
	sb.WriteString("    for field in struct_def.get('fields', []):\n")
	sb.WriteString("        if field['name'] not in field_names:\n")
	sb.WriteString("            fields.append(field)\n")
	sb.WriteString("            field_names.add(field['name'])\n")
	sb.WriteString("        else:\n")
	sb.WriteString("            # Override parent field\n")
	sb.WriteString("            for i, f in enumerate(fields):\n")
	sb.WriteString("                if f['name'] == field['name']:\n")
	sb.WriteString("                    fields[i] = field\n")
	sb.WriteString("                    break\n")
	sb.WriteString("    \n")
	sb.WriteString("    return fields\n\n")

	// Built-in type validators
	sb.WriteString("def validate_string(value: Any) -> None:\n")
	sb.WriteString("    \"\"\"Validate that value is a string\"\"\"\n")
	sb.WriteString("    if not isinstance(value, str):\n")
	sb.WriteString("        raise TypeError(f\"Expected string, got {type(value).__name__}\")\n\n")

	sb.WriteString("def validate_int(value: Any) -> None:\n")
	sb.WriteString("    \"\"\"Validate that value is an int\"\"\"\n")
	sb.WriteString("    if not isinstance(value, int):\n")
	sb.WriteString("        raise TypeError(f\"Expected int, got {type(value).__name__}\")\n\n")

	sb.WriteString("def validate_float(value: Any) -> None:\n")
	sb.WriteString("    \"\"\"Validate that value is a float or int\"\"\"\n")
	sb.WriteString("    if not isinstance(value, (int, float)):\n")
	sb.WriteString("        raise TypeError(f\"Expected float, got {type(value).__name__}\")\n\n")

	sb.WriteString("def validate_bool(value: Any) -> None:\n")
	sb.WriteString("    \"\"\"Validate that value is a bool\"\"\"\n")
	sb.WriteString("    if not isinstance(value, bool):\n")
	sb.WriteString("        raise TypeError(f\"Expected bool, got {type(value).__name__}\")\n\n")

	// Array validator
	sb.WriteString("def validate_array(value: Any, element_validator: Callable[[Any], None]) -> None:\n")
	sb.WriteString("    \"\"\"Validate that value is an array and each element passes validation\"\"\"\n")
	sb.WriteString("    if not isinstance(value, list):\n")
	sb.WriteString("        raise TypeError(f\"Expected list, got {type(value).__name__}\")\n")
	sb.WriteString("    for i, elem in enumerate(value):\n")
	sb.WriteString("        try:\n")
	sb.WriteString("            element_validator(elem)\n")
	sb.WriteString("        except Exception as e:\n")
	sb.WriteString("            raise ValueError(f\"Array element at index {i} validation failed: {e}\") from e\n\n")

	// Map validator
	sb.WriteString("def validate_map(value: Any, value_validator: Callable[[Any], None]) -> None:\n")
	sb.WriteString("    \"\"\"Validate that value is a map (dict) with string keys and validated values\"\"\"\n")
	sb.WriteString("    if not isinstance(value, dict):\n")
	sb.WriteString("        raise TypeError(f\"Expected dict, got {type(value).__name__}\")\n")
	sb.WriteString("    for key, val in value.items():\n")
	sb.WriteString("        if not isinstance(key, str):\n")
	sb.WriteString("            raise TypeError(f\"Map key must be string, got {type(key).__name__}\")\n")
	sb.WriteString("        try:\n")
	sb.WriteString("            value_validator(val)\n")
	sb.WriteString("        except Exception as e:\n")
	sb.WriteString("            raise ValueError(f\"Map value for key '{key}' validation failed: {e}\") from e\n\n")

	// Enum validator
	sb.WriteString("def validate_enum(value: Any, enum_name: str, allowed_values: List[str]) -> None:\n")
	sb.WriteString("    \"\"\"Validate that value is a string and matches one of the allowed enum values\"\"\"\n")
	sb.WriteString("    if not isinstance(value, str):\n")
	sb.WriteString("        raise TypeError(f\"Expected string for enum {enum_name}, got {type(value).__name__}\")\n")
	sb.WriteString("    if value not in allowed_values:\n")
	sb.WriteString("        raise ValueError(f\"Invalid value for enum {enum_name}: '{value}'. Allowed values: {allowed_values}\")\n\n")

	// Struct validator
	sb.WriteString("def validate_struct(value: Any, struct_name: str, struct_def: Dict[str, Any], all_structs: Dict[str, Any], all_enums: Dict[str, Any]) -> None:\n")
	sb.WriteString("    \"\"\"Validate that value is a dict matching the struct definition\"\"\"\n")
	sb.WriteString("    if not isinstance(value, dict):\n")
	sb.WriteString("        raise TypeError(f\"Expected dict for struct {struct_name}, got {type(value).__name__}\")\n")
	sb.WriteString("    \n")
	sb.WriteString("    # Get all fields including parent fields\n")
	sb.WriteString("    fields = get_struct_fields(struct_name, all_structs)\n")
	sb.WriteString("    \n")
	sb.WriteString("    # Check required fields\n")
	sb.WriteString("    for field in fields:\n")
	sb.WriteString("        field_name = field['name']\n")
	sb.WriteString("        field_type = field['type']\n")
	sb.WriteString("        is_optional = field.get('optional', False)\n")
	sb.WriteString("        \n")
	sb.WriteString("        if field_name not in value:\n")
	sb.WriteString("            if not is_optional:\n")
	sb.WriteString("                raise ValueError(f\"Missing required field '{field_name}' in struct {struct_name}\")\n")
	sb.WriteString("        else:\n")
	sb.WriteString("            # Field is present, validate it\n")
	sb.WriteString("            field_value = value[field_name]\n")
	sb.WriteString("            if field_value is None:\n")
	sb.WriteString("                if not is_optional:\n")
	sb.WriteString("                    raise ValueError(f\"Field '{field_name}' in struct {struct_name} cannot be None\")\n")
	sb.WriteString("            else:\n")
	sb.WriteString("                # Create validator for this field type\n")
	sb.WriteString("                field_validator = lambda v: validate_type(v, field_type, all_structs, all_enums, is_optional)\n")
	sb.WriteString("                try:\n")
	sb.WriteString("                    field_validator(field_value)\n")
	sb.WriteString("                except Exception as e:\n")
	sb.WriteString("                    raise ValueError(f\"Field '{field_name}' in struct {struct_name} validation failed: {e}\") from e\n\n")

	// Main type validator
	sb.WriteString("def validate_type(value: Any, type_def: Dict[str, Any], all_structs: Dict[str, Any], all_enums: Dict[str, Any], is_optional: bool = False) -> None:\n")
	sb.WriteString("    \"\"\"Validate a value against a type definition\"\"\"\n")
	sb.WriteString("    # Handle optional types\n")
	sb.WriteString("    if value is None:\n")
	sb.WriteString("        if is_optional:\n")
	sb.WriteString("            return\n")
	sb.WriteString("        else:\n")
	sb.WriteString("            raise ValueError(\"Value cannot be None for non-optional type\")\n")
	sb.WriteString("    \n")
	sb.WriteString("    # Built-in types\n")
	sb.WriteString("    if type_def.get('builtIn') == 'string':\n")
	sb.WriteString("        validate_string(value)\n")
	sb.WriteString("    elif type_def.get('builtIn') == 'int':\n")
	sb.WriteString("        validate_int(value)\n")
	sb.WriteString("    elif type_def.get('builtIn') == 'float':\n")
	sb.WriteString("        validate_float(value)\n")
	sb.WriteString("    elif type_def.get('builtIn') == 'bool':\n")
	sb.WriteString("        validate_bool(value)\n")
	sb.WriteString("    # Array types\n")
	sb.WriteString("    elif type_def.get('array'):\n")
	sb.WriteString("        element_type = type_def['array']\n")
	sb.WriteString("        element_validator = lambda v: validate_type(v, element_type, all_structs, all_enums, False)\n")
	sb.WriteString("        validate_array(value, element_validator)\n")
	sb.WriteString("    # Map types\n")
	sb.WriteString("    elif type_def.get('mapValue'):\n")
	sb.WriteString("        value_type = type_def['mapValue']\n")
	sb.WriteString("        value_validator = lambda v: validate_type(v, value_type, all_structs, all_enums, False)\n")
	sb.WriteString("        validate_map(value, value_validator)\n")
	sb.WriteString("    # User-defined types\n")
	sb.WriteString("    elif type_def.get('userDefined'):\n")
	sb.WriteString("        user_type = type_def['userDefined']\n")
	sb.WriteString("        # Check if it's a struct\n")
	sb.WriteString("        struct_def = find_struct(user_type, all_structs)\n")
	sb.WriteString("        if struct_def:\n")
	sb.WriteString("            validate_struct(value, user_type, struct_def, all_structs, all_enums)\n")
	sb.WriteString("        # Check if it's an enum\n")
	sb.WriteString("        else:\n")
	sb.WriteString("            enum_def = find_enum(user_type, all_enums)\n")
	sb.WriteString("            if enum_def:\n")
	sb.WriteString("                allowed_values = [v['name'] for v in enum_def.get('values', [])]\n")
	sb.WriteString("                validate_enum(value, user_type, allowed_values)\n")
	sb.WriteString("            else:\n")
	sb.WriteString("                raise ValueError(f\"Unknown user-defined type: {user_type}\")\n")
	sb.WriteString("    else:\n")
	sb.WriteString("        raise ValueError(f\"Invalid type definition: {type_def}\")\n\n")

	// Generate type definitions as Python dicts
	sb.WriteString("# Type definitions\n")
	sb.WriteString("ALL_STRUCTS = {\n")
	for _, s := range idl.Structs {
		sb.WriteString(fmt.Sprintf("    '%s': {\n", s.Name))
		if s.Extends != "" {
			sb.WriteString(fmt.Sprintf("        'extends': '%s',\n", s.Extends))
		}
		sb.WriteString("        'fields': [\n")
		for _, field := range s.Fields {
			sb.WriteString("            {\n")
			sb.WriteString(fmt.Sprintf("                'name': '%s',\n", field.Name))
			sb.WriteString("                'type': ")
			writeTypeDict(&sb, field.Type)
			sb.WriteString(",\n")
			if field.Optional {
				sb.WriteString("                'optional': True,\n")
			}
			sb.WriteString("            },\n")
		}
		sb.WriteString("        ],\n")
		sb.WriteString("    },\n")
	}
	sb.WriteString("}\n\n")

	sb.WriteString("ALL_ENUMS = {\n")
	for _, e := range idl.Enums {
		sb.WriteString(fmt.Sprintf("    '%s': {\n", e.Name))
		sb.WriteString("        'values': [\n")
		for _, val := range e.Values {
			sb.WriteString(fmt.Sprintf("            {'name': '%s'},\n", val.Name))
		}
		sb.WriteString("        ],\n")
		sb.WriteString("    },\n")
	}
	sb.WriteString("}\n")

	return sb.String()
}

// writeTypeDict writes a type definition as a Python dict
func writeTypeDict(sb *strings.Builder, t *parser.Type) {
	sb.WriteString("{")
	if t.IsBuiltIn() {
		fmt.Fprintf(sb, "'builtIn': '%s'", t.BuiltIn)
	} else if t.IsArray() {
		sb.WriteString("'array': ")
		writeTypeDict(sb, t.Array)
	} else if t.IsMap() {
		sb.WriteString("'mapValue': ")
		writeTypeDict(sb, t.MapValue)
	} else if t.IsUserDefined() {
		fmt.Fprintf(sb, "'userDefined': '%s'", t.UserDefined)
	}
	sb.WriteString("}")
}

// generateServerPy generates the server.py file with Flask server and interface stubs
func generateServerPy(idl *parser.IDL, structMap map[string]*parser.Struct, enumMap map[string]*parser.Enum, interfaceMap map[string]*parser.Interface) string {
	var sb strings.Builder

	sb.WriteString("# Generated by barrister - do not edit\n\n")
	sb.WriteString("import abc\n")
	sb.WriteString("import json\n")
	sb.WriteString("from typing import Any, Dict, List, Optional\n\n")
	sb.WriteString("from flask import Flask, request, jsonify\n")
	sb.WriteString("from barrister import RPCError, validate_type, ALL_STRUCTS, ALL_ENUMS\n\n")

	// Generate interface stub classes
	for _, iface := range idl.Interfaces {
		writeInterfaceStub(&sb, iface)
	}

	// Generate BarristerServer class
	sb.WriteString("class BarristerServer:\n")
	sb.WriteString("    \"\"\"Flask server for JSON-RPC 2.0 requests\"\"\"\n\n")
	sb.WriteString("    def __init__(self):\n")
	sb.WriteString("        self.app = Flask(__name__)\n")
	sb.WriteString("        self.handlers: Dict[str, Any] = {}\n")
	sb.WriteString("        self._setup_routes()\n\n")

	sb.WriteString("    def register(self, interface_name: str, instance: Any) -> None:\n")
	sb.WriteString("        \"\"\"Register an interface implementation instance\"\"\"\n")
	sb.WriteString("        self.handlers[interface_name] = instance\n\n")

	sb.WriteString("    def _setup_routes(self) -> None:\n")
	sb.WriteString("        @self.app.route('/', methods=['POST'])\n")
	sb.WriteString("        def handle_post():\n")
	sb.WriteString("            try:\n")
	sb.WriteString("                data = request.get_json()\n")
	sb.WriteString("                if data is None:\n")
	sb.WriteString("                    return jsonify(self._error_response(None, -32700, \"Parse error\", \"Invalid JSON\"))\n")
	sb.WriteString("                \n")
	sb.WriteString("                # Handle batch requests\n")
	sb.WriteString("                if isinstance(data, list):\n")
	sb.WriteString("                    if len(data) == 0:\n")
	sb.WriteString("                        return jsonify(self._error_response(None, -32600, \"Invalid Request\", \"Empty batch array\"))\n")
	sb.WriteString("                    responses = []\n")
	sb.WriteString("                    for req in data:\n")
	sb.WriteString("                        response = self.handle_request(req)\n")
	sb.WriteString("                        if response is not None:\n")
	sb.WriteString("                            responses.append(response)\n")
	sb.WriteString("                    if len(responses) == 0:\n")
	sb.WriteString("                        return '', 204  # No content for all notifications\n")
	sb.WriteString("                    return jsonify(responses)\n")
	sb.WriteString("                else:\n")
	sb.WriteString("                    response = self.handle_request(data)\n")
	sb.WriteString("                    if response is None:\n")
	sb.WriteString("                        return '', 204  # Notification\n")
	sb.WriteString("                    return jsonify(response)\n")
	sb.WriteString("            except Exception as e:\n")
	sb.WriteString("                return jsonify(self._error_response(None, -32603, \"Internal error\", str(e)))\n\n")

	sb.WriteString("    def handle_request(self, request_json: Dict[str, Any]) -> Optional[Dict[str, Any]]:\n")
	sb.WriteString("        \"\"\"Handle a single JSON-RPC 2.0 request\"\"\"\n")
	sb.WriteString("        # Validate JSON-RPC 2.0 structure\n")
	sb.WriteString("        if not isinstance(request_json, dict):\n")
	sb.WriteString("            return self._error_response(None, -32600, \"Invalid Request\", \"Request must be an object\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        jsonrpc = request_json.get('jsonrpc')\n")
	sb.WriteString("        if jsonrpc != '2.0':\n")
	sb.WriteString("            return self._error_response(None, -32600, \"Invalid Request\", \"jsonrpc must be '2.0'\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        method = request_json.get('method')\n")
	sb.WriteString("        if not isinstance(method, str):\n")
	sb.WriteString("            return self._error_response(None, -32600, \"Invalid Request\", \"method must be a string\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        params = request_json.get('params')\n")
	sb.WriteString("        request_id = request_json.get('id')\n")
	sb.WriteString("        is_notification = 'id' not in request_json\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Parse method name: interface.method\n")
	sb.WriteString("        parts = method.split('.', 1)\n")
	sb.WriteString("        if len(parts) != 2:\n")
	sb.WriteString("            return self._error_response(request_id, -32601, \"Method not found\", f\"Invalid method format: {method}\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        interface_name, method_name = parts\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Find handler\n")
	sb.WriteString("        handler = self.handlers.get(interface_name)\n")
	sb.WriteString("        if handler is None:\n")
	sb.WriteString("            return self._error_response(request_id, -32601, \"Method not found\", f\"Interface '{interface_name}' not registered\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Find method on handler\n")
	sb.WriteString("        if not hasattr(handler, method_name):\n")
	sb.WriteString("            return self._error_response(request_id, -32601, \"Method not found\", f\"Method '{method_name}' not found on interface '{interface_name}'\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        method_func = getattr(handler, method_name)\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Find interface and method definition\n")
	writeInterfaceMethodLookup(&sb, idl.Interfaces)
	sb.WriteString("        \n")
	sb.WriteString("        if method_def is None:\n")
	sb.WriteString("            return self._error_response(request_id, -32601, \"Method not found\", f\"Method '{method_name}' not found in interface '{interface_name}'\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Validate params\n")
	sb.WriteString("        if params is None:\n")
	sb.WriteString("            params = []\n")
	sb.WriteString("        if not isinstance(params, list):\n")
	sb.WriteString("            return self._error_response(request_id, -32602, \"Invalid params\", \"params must be an array\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Validate param count\n")
	sb.WriteString("        expected_params = method_def.get('parameters', [])\n")
	sb.WriteString("        if len(params) != len(expected_params):\n")
	sb.WriteString("            return self._error_response(request_id, -32602, \"Invalid params\", f\"Expected {len(expected_params)} parameters, got {len(params)}\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Validate each param\n")
	sb.WriteString("        for i, (param_value, param_def) in enumerate(zip(params, expected_params)):\n")
	sb.WriteString("            try:\n")
	sb.WriteString("                validate_type(param_value, param_def['type'], ALL_STRUCTS, ALL_ENUMS, False)\n")
	sb.WriteString("            except Exception as e:\n")
	sb.WriteString("                return self._error_response(request_id, -32602, \"Invalid params\", f\"Parameter {i} ({param_def['name']}) validation failed: {e}\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Invoke handler\n")
	sb.WriteString("        try:\n")
	sb.WriteString("            result = method_func(*params)\n")
	sb.WriteString("        except RPCError as e:\n")
	sb.WriteString("            return self._error_response(request_id, e.code, e.message, e.data)\n")
	sb.WriteString("        except Exception as e:\n")
	sb.WriteString("            return self._error_response(request_id, -32603, \"Internal error\", str(e))\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Validate response\n")
	sb.WriteString("        return_type = method_def.get('returnType')\n")
	sb.WriteString("        return_optional = method_def.get('returnOptional', False)\n")
	sb.WriteString("        if return_type:\n")
	sb.WriteString("            try:\n")
	sb.WriteString("                validate_type(result, return_type, ALL_STRUCTS, ALL_ENUMS, return_optional)\n")
	sb.WriteString("            except Exception as e:\n")
	sb.WriteString("                return self._error_response(request_id, -32603, \"Internal error\", f\"Response validation failed: {e}\")\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Return success response\n")
	sb.WriteString("        if is_notification:\n")
	sb.WriteString("            return None\n")
	sb.WriteString("        return {\n")
	sb.WriteString("            'jsonrpc': '2.0',\n")
	sb.WriteString("            'result': result,\n")
	sb.WriteString("            'id': request_id\n")
	sb.WriteString("        }\n\n")

	sb.WriteString("    def _error_response(self, request_id: Any, code: int, message: str, data: Any = None) -> Dict[str, Any]:\n")
	sb.WriteString("        \"\"\"Create a JSON-RPC 2.0 error response\"\"\"\n")
	sb.WriteString("        error = {\n")
	sb.WriteString("            'code': code,\n")
	sb.WriteString("            'message': message\n")
	sb.WriteString("        }\n")
	sb.WriteString("        if data is not None:\n")
	sb.WriteString("            error['data'] = data\n")
	sb.WriteString("        return {\n")
	sb.WriteString("            'jsonrpc': '2.0',\n")
	sb.WriteString("            'error': error,\n")
	sb.WriteString("            'id': request_id\n")
	sb.WriteString("        }\n")

	return sb.String()
}

// writeInterfaceStub writes an abstract base class for an interface
func writeInterfaceStub(sb *strings.Builder, iface *parser.Interface) {
	if iface.Comment != "" {
		lines := strings.Split(strings.TrimSpace(iface.Comment), "\n")
		for _, line := range lines {
			fmt.Fprintf(sb, "# %s\n", line)
		}
	}
	fmt.Fprintf(sb, "class %s(abc.ABC):\n", iface.Name)
	if iface.Comment != "" {
		fmt.Fprintf(sb, "    \"\"\"%s\"\"\"\n", strings.TrimSpace(iface.Comment))
	}
	sb.WriteString("\n")

	for _, method := range iface.Methods {
		sb.WriteString("    @abc.abstractmethod\n")
		fmt.Fprintf(sb, "    def %s(self", method.Name)
		for _, param := range method.Parameters {
			fmt.Fprintf(sb, ", %s", param.Name)
		}
		sb.WriteString("):\n")
		sb.WriteString("        pass\n\n")
	}
	sb.WriteString("\n")
}

// writeInterfaceMethodLookup generates code to find method definitions
func writeInterfaceMethodLookup(sb *strings.Builder, interfaces []*parser.Interface) {
	sb.WriteString("        method_def = None\n")
	sb.WriteString("        \n")
	sb.WriteString("        # Interface method lookup\n")
	for i, iface := range interfaces {
		if i == 0 {
			fmt.Fprintf(sb, "        if interface_name == '%s':\n", iface.Name)
		} else {
			fmt.Fprintf(sb, "        elif interface_name == '%s':\n", iface.Name)
		}
		sb.WriteString("            interface_methods = {\n")
		for _, method := range iface.Methods {
			fmt.Fprintf(sb, "                '%s': {\n", method.Name)
			sb.WriteString("                    'parameters': [\n")
			for _, param := range method.Parameters {
				sb.WriteString("                        {\n")
				fmt.Fprintf(sb, "                            'name': '%s',\n", param.Name)
				sb.WriteString("                            'type': ")
				writeTypeDict(sb, param.Type)
				sb.WriteString(",\n")
				sb.WriteString("                        },\n")
			}
			sb.WriteString("                    ],\n")
			sb.WriteString("                    'returnType': ")
			writeTypeDict(sb, method.ReturnType)
			sb.WriteString(",\n")
			sb.WriteString("                    'returnOptional': False,\n")
			sb.WriteString("                },\n")
		}
		sb.WriteString("            }\n")
		sb.WriteString("            method_def = interface_methods.get(method_name)\n")
	}
	sb.WriteString("\n")
}
