// Generated by barrister - do not edit

package checkout;

import com.bitmechanic.barrister2.*;
import com.sun.net.httpserver.HttpServer;
import com.sun.net.httpserver.HttpExchange;
import java.io.*;
import java.net.*;
import java.util.*;
import java.lang.reflect.*;

import checkout.checkout.CatalogService;
import checkout.checkout.CartService;
import checkout.checkout.OrderService;

public class Server {
    private final HttpServer server;
    private final JsonParser jsonParser;
    private final Map<String, Object> interfaceHandlers;

    public Server(int port, JsonParser jsonParser) throws IOException {
        this.jsonParser = jsonParser;
        this.server = HttpServer.create(new InetSocketAddress(port), 0);
        this.server.createContext("/", this::handleRequest);
        this.interfaceHandlers = new HashMap<>();
    }

    public void register(String interfaceName, Object implementation) {
        interfaceHandlers.put(interfaceName, implementation);
    }

    public void start() {
        server.start();
        System.out.println("Server started on port " + server.getAddress().getPort());
    }

    public void stop() {
        server.stop(0);
    }

    private void handleRequest(HttpExchange exchange) throws IOException {
        try {
            if (!"POST".equals(exchange.getRequestMethod())) {
                sendError(exchange, -32600, "Invalid Request - only POST allowed");
                return;
            }

            // Read request body
            String requestBody = new String(exchange.getRequestBody().readAllBytes());

            // Parse JSON-RPC request
            Map<String, Object> request = jsonParser.fromJson(requestBody, Map.class);

            // Handle the request
            Map<String, Object> response = handleJsonRpcRequest(request);

            // Send response
            String responseBody = jsonParser.toJson(response);
            exchange.getResponseHeaders().set("Content-Type", "application/json");
            exchange.sendResponseHeaders(200, responseBody.getBytes().length);
            try (OutputStream os = exchange.getResponseBody()) {
                os.write(responseBody.getBytes());
            }
        } catch (Exception e) {
            sendError(exchange, -32603, "Internal error: " + e.getMessage());
        }
    }

    private void sendError(HttpExchange exchange, int code, String message) throws IOException {
        Map<String, Object> error = Map.of(
            "jsonrpc", "2.0",
            "error", Map.of(
                "code", code,
                "message", message
            ),
            "id", null
        );
        String errorBody = jsonParser.toJson(error);
        exchange.getResponseHeaders().set("Content-Type", "application/json");
        exchange.sendResponseHeaders(200, errorBody.getBytes().length);
        try (OutputStream os = exchange.getResponseBody()) {
            os.write(errorBody.getBytes());
        }
    }

    private Map<String, Object> handleJsonRpcRequest(Map<String, Object> request) {
        // Validate jsonrpc field
        Object jsonrpc = request.get("jsonrpc");
        if (jsonrpc == null || !"2.0".equals(jsonrpc)) {
            Object id = request.get("id");
            return Map.of(
                "jsonrpc", "2.0",
                "error", Map.of(
                    "code", -32600,
                    "message", "Invalid Request - jsonrpc must be '2.0'"
                ),
                "id", id
            );
        }

        String method = (String) request.get("method");
        Object id = request.get("id");
        Object params = request.get("params");

        if ("barrister-idl".equals(method)) {
            // Return IDL definition - read from idl.json
            try {
                String idlJson = new String(java.nio.file.Files.readAllBytes(java.nio.file.Paths.get("idl.json")));
                Object idlDoc = jsonParser.fromJson(idlJson, Object.class);
                return Map.of(
                    "jsonrpc", "2.0",
                    "result", idlDoc,
                    "id", id
                );
            } catch (Exception e) {
                return Map.of(
                    "jsonrpc", "2.0",
                    "error", Map.of(
                        "code", -32603,
                        "message", "Failed to load IDL: " + e.getMessage()
                    ),
                    "id", id
                );
            }
        }

        // Parse method name: interface.method
        String[] parts = method.split("\\.", 2);
        if (parts.length != 2) {
            return Map.of(
                "jsonrpc", "2.0",
                "error", Map.of(
                    "code", -32601,
                    "message", "Invalid method format: " + method
                ),
                "id", id
            );
        }

        String interfaceName = parts[0];
        String methodName = parts[1];

        // Find interface handler
        Object handler = interfaceHandlers.get(interfaceName);
        if (handler == null) {
            return Map.of(
                "jsonrpc", "2.0",
                "error", Map.of(
                    "code", -32601,
                    "message", "Interface not found: " + interfaceName
                ),
                "id", id
            );
        }

                // Invoke method using reflection
        try {
            // Handle null params (methods with no parameters)
            List<?> paramList;
            if (params == null) {
                paramList = new ArrayList<>();
            } else if (params instanceof List) {
                paramList = (List<?>) params;
            } else {
                return Map.of(
                    "jsonrpc", "2.0",
                    "error", Map.of(
                        "code", -32602,
                        "message", "Invalid params: must be an array"
                    ),
                    "id", id
                );
            }

            Class<?> handlerClass = handler.getClass();
            Method[] methods = handlerClass.getMethods();
            Method targetMethod = null;
            boolean methodNameFound = false;
            for (Method m : methods) {
                if (m.getName().equals(methodName)) {
                    methodNameFound = true;
                    if (m.getParameterCount() == paramList.size()) {
                        targetMethod = m;
                        break;
                    }
                }
            }

            if (!methodNameFound) {
                return Map.of(
                    "jsonrpc", "2.0",
                    "error", Map.of(
                        "code", -32601,
                        "message", "Method not found: " + method
                    ),
                    "id", id
                );
            }

            if (targetMethod == null) {
                return Map.of(
                    "jsonrpc", "2.0",
                    "error", Map.of(
                        "code", -32602,
                        "message", "Invalid params: parameter count mismatch for " + method
                    ),
                    "id", id
                );
            }

            // Deserialize parameters using generic types
            java.lang.reflect.Type[] paramTypes = targetMethod.getGenericParameterTypes();
            Object[] deserializedParams = new Object[paramList.size()];
            try {
                for (int i = 0; i < paramList.size(); i++) {
                    String paramJson = jsonParser.toJson(paramList.get(i));
                    deserializedParams[i] = jsonParser.fromJson(paramJson, paramTypes[i]);
                }
            } catch (Exception deserEx) {
                // Deserialization errors should return -32602 (Invalid params)
                return Map.of(
                    "jsonrpc", "2.0",
                    "error", Map.of(
                        "code", -32602,
                        "message", "Invalid params: " + deserEx.getMessage()
                    ),
                    "id", id
                );
            }

            // Invoke method
            Object result = targetMethod.invoke(handler, deserializedParams);

            // Return response (use HashMap to allow null result values)
            Map<String, Object> response = new HashMap<>();
            response.put("jsonrpc", "2.0");
            response.put("result", result);
            response.put("id", id);
            return response;
        } catch (java.lang.reflect.InvocationTargetException ite) {
            // Unwrap InvocationTargetException to get the actual exception
            Throwable cause = ite.getCause();
            if (cause instanceof RPCError) {
                RPCError rpcErr = (RPCError) cause;
                return Map.of(
                    "jsonrpc", "2.0",
                    "error", Map.of(
                        "code", rpcErr.getCode(),
                        "message", rpcErr.getMessage(),
                        "data", rpcErr.getData()
                    ),
                    "id", id
                );
            } else {
                // Print stack trace for unexpected exceptions
                System.err.println("Exception in method " + method + ":");
                if (cause != null) {
                    cause.printStackTrace();
                } else {
                    ite.printStackTrace();
                }
                return Map.of(
                    "jsonrpc", "2.0",
                    "error", Map.of(
                        "code", -32603,
                        "message", "Internal error: " + (cause != null ? cause.getMessage() : ite.getMessage())
                    ),
                    "id", id
                );
            }
        } catch (RPCError rpcErr) {
            // RPCError is expected and can be thrown by implementations
            return Map.of(
                "jsonrpc", "2.0",
                "error", Map.of(
                    "code", rpcErr.getCode(),
                    "message", rpcErr.getMessage(),
                    "data", rpcErr.getData()
                ),
                "id", id
            );
        } catch (Exception e) {
            // Print stack trace for unexpected exceptions
            System.err.println("Exception in method " + method + ":");
            e.printStackTrace();
            return Map.of(
                "jsonrpc", "2.0",
                "error", Map.of(
                    "code", -32603,
                    "message", "Internal error: " + e.getMessage()
                ),
                "id", id
            );
        }
    }
}
