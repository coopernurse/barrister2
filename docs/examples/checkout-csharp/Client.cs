// Generated by barrister - do not edit

using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using Barrister2;

using static checkoutIdl;

// Merge ALL_STRUCTS and ALL_ENUMS from all namespaces
public static class IdlData
{
    public static Dictionary<string, Dictionary<string, object>> ALL_STRUCTS = new Dictionary<string, Dictionary<string, object>>();
    public static Dictionary<string, Dictionary<string, object>> ALL_ENUMS = new Dictionary<string, Dictionary<string, object>>();
    
    static IdlData()
    {
        foreach (var kvp in checkoutIdl.ALL_STRUCTS) ALL_STRUCTS[kvp.Key] = kvp.Value;
        foreach (var kvp in checkoutIdl.ALL_ENUMS) ALL_ENUMS[kvp.Key] = kvp.Value;
    }
}

public interface ITransport
{
    Task<Dictionary<string, object?>> CallAsync(string method, object[] parameters);
}

public class HttpTransport : ITransport
{
    private readonly HttpClient _httpClient;
    private readonly string _baseUrl;

    public HttpTransport(string baseUrl, Dictionary<string, string>? headers = null)
    {
        _baseUrl = baseUrl.TrimEnd('/');
        _httpClient = new HttpClient();
        if (headers != null)
        {
            foreach (var header in headers)
            {
                _httpClient.DefaultRequestHeaders.Add(header.Key, header.Value);
            }
        }
    }

    public async Task<Dictionary<string, object?>> CallAsync(string method, object[] parameters)
    {
        var requestId = Guid.NewGuid().ToString();
        var request = new Dictionary<string, object?>
        {
            { "jsonrpc", "2.0" },
            { "method", method },
            { "params", parameters },
            { "id", requestId }
        };

        var json = JsonSerializer.Serialize(request);
        var content = new StringContent(json, System.Text.Encoding.UTF8, "application/json");

        var response = await _httpClient.PostAsync(_baseUrl, content);
        response.EnsureSuccessStatusCode();

        var responseJson = await response.Content.ReadAsStringAsync();
        var responseDict = JsonSerializer.Deserialize<Dictionary<string, object?>>(responseJson);

        if (responseDict != null && responseDict.TryGetValue("error", out var errorObj) && errorObj != null)
        {
            var error = errorObj as Dictionary<string, object?>;
            var code = error != null && error.TryGetValue("code", out var codeObj) ? Convert.ToInt32(codeObj) : -32603;
            var message = error != null && error.TryGetValue("message", out var msgObj) ? msgObj?.ToString() ?? "" : "Unknown error";
            object? data = error != null && error.TryGetValue("data", out var dataObj) ? dataObj : null;
            throw new RPCError(code, message, data);
        }

        return responseDict ?? new Dictionary<string, object?>();
    }
}

public class CatalogServiceClient
{
    private readonly ITransport _transport;

    public CatalogServiceClient(ITransport transport)
    {
        _transport = transport;
    }

    public async Task<List<Product>> listProductsAsync()
    {

        var method = "CatalogService.listProducts";
        var parameters = new object[] {  };

        var response = await _transport.CallAsync(method, parameters);
        if (!response.TryGetValue("result", out var result)) {
            throw new RPCError(-32603, "Internal error", "Missing result in response");
        }

        // Deserialize to return type
        string resultJsonStr;
        if (result is System.Text.Json.JsonElement jsonElement)
        {
            resultJsonStr = jsonElement.GetRawText();
        }
        else
        {
            resultJsonStr = JsonSerializer.Serialize(result);
        }
        var clientJsonOptions = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true
        };
        clientJsonOptions.Converters.Add(new JsonStringEnumConverter());
        return JsonSerializer.Deserialize<List<Product>>(resultJsonStr, clientJsonOptions);
    }

    public async Task<Product?> getProductAsync(string productId)
    {

        var method = "CatalogService.getProduct";
        var parameters = new object[] { productId };

        var response = await _transport.CallAsync(method, parameters);
        if (!response.TryGetValue("result", out var result)) {
            return default;
        }

        // Deserialize to return type
        string resultJsonStr;
        if (result is System.Text.Json.JsonElement jsonElement)
        {
            resultJsonStr = jsonElement.GetRawText();
        }
        else
        {
            resultJsonStr = JsonSerializer.Serialize(result);
        }
        var clientJsonOptions = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true
        };
        clientJsonOptions.Converters.Add(new JsonStringEnumConverter());
        return JsonSerializer.Deserialize<Product?>(resultJsonStr, clientJsonOptions);
    }

}

public class CartServiceClient
{
    private readonly ITransport _transport;

    public CartServiceClient(ITransport transport)
    {
        _transport = transport;
    }

    public async Task<Cart> addToCartAsync(AddToCartRequest request)
    {

        var method = "CartService.addToCart";
        var parameters = new object[] { request };

        var response = await _transport.CallAsync(method, parameters);
        if (!response.TryGetValue("result", out var result)) {
            throw new RPCError(-32603, "Internal error", "Missing result in response");
        }

        // Deserialize to return type
        string resultJsonStr;
        if (result is System.Text.Json.JsonElement jsonElement)
        {
            resultJsonStr = jsonElement.GetRawText();
        }
        else
        {
            resultJsonStr = JsonSerializer.Serialize(result);
        }
        var clientJsonOptions = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true
        };
        clientJsonOptions.Converters.Add(new JsonStringEnumConverter());
        return JsonSerializer.Deserialize<Cart>(resultJsonStr, clientJsonOptions);
    }

    public async Task<Cart?> getCartAsync(string cartId)
    {

        var method = "CartService.getCart";
        var parameters = new object[] { cartId };

        var response = await _transport.CallAsync(method, parameters);
        if (!response.TryGetValue("result", out var result)) {
            return default;
        }

        // Deserialize to return type
        string resultJsonStr;
        if (result is System.Text.Json.JsonElement jsonElement)
        {
            resultJsonStr = jsonElement.GetRawText();
        }
        else
        {
            resultJsonStr = JsonSerializer.Serialize(result);
        }
        var clientJsonOptions = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true
        };
        clientJsonOptions.Converters.Add(new JsonStringEnumConverter());
        return JsonSerializer.Deserialize<Cart?>(resultJsonStr, clientJsonOptions);
    }

    public async Task<bool> clearCartAsync(string cartId)
    {

        var method = "CartService.clearCart";
        var parameters = new object[] { cartId };

        var response = await _transport.CallAsync(method, parameters);
        if (!response.TryGetValue("result", out var result)) {
            throw new RPCError(-32603, "Internal error", "Missing result in response");
        }

        // Deserialize to return type
        string resultJsonStr;
        if (result is System.Text.Json.JsonElement jsonElement)
        {
            resultJsonStr = jsonElement.GetRawText();
        }
        else
        {
            resultJsonStr = JsonSerializer.Serialize(result);
        }
        var clientJsonOptions = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true
        };
        clientJsonOptions.Converters.Add(new JsonStringEnumConverter());
        return JsonSerializer.Deserialize<bool>(resultJsonStr, clientJsonOptions);
    }

}

public class OrderServiceClient
{
    private readonly ITransport _transport;

    public OrderServiceClient(ITransport transport)
    {
        _transport = transport;
    }

    public async Task<CheckoutResponse> createOrderAsync(CreateOrderRequest request)
    {

        var method = "OrderService.createOrder";
        var parameters = new object[] { request };

        var response = await _transport.CallAsync(method, parameters);
        if (!response.TryGetValue("result", out var result)) {
            throw new RPCError(-32603, "Internal error", "Missing result in response");
        }

        // Deserialize to return type
        string resultJsonStr;
        if (result is System.Text.Json.JsonElement jsonElement)
        {
            resultJsonStr = jsonElement.GetRawText();
        }
        else
        {
            resultJsonStr = JsonSerializer.Serialize(result);
        }
        var clientJsonOptions = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true
        };
        clientJsonOptions.Converters.Add(new JsonStringEnumConverter());
        return JsonSerializer.Deserialize<CheckoutResponse>(resultJsonStr, clientJsonOptions);
    }

    public async Task<Order?> getOrderAsync(string orderId)
    {

        var method = "OrderService.getOrder";
        var parameters = new object[] { orderId };

        var response = await _transport.CallAsync(method, parameters);
        if (!response.TryGetValue("result", out var result)) {
            return default;
        }

        // Deserialize to return type
        string resultJsonStr;
        if (result is System.Text.Json.JsonElement jsonElement)
        {
            resultJsonStr = jsonElement.GetRawText();
        }
        else
        {
            resultJsonStr = JsonSerializer.Serialize(result);
        }
        var clientJsonOptions = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true
        };
        clientJsonOptions.Converters.Add(new JsonStringEnumConverter());
        return JsonSerializer.Deserialize<Order?>(resultJsonStr, clientJsonOptions);
    }

}

