// Generated by barrister - do not edit

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using Microsoft.AspNetCore.Builder;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.DependencyInjection;
using Barrister2;

using static checkoutIdl;

// Merge ALL_STRUCTS and ALL_ENUMS from all namespaces
public static class IdlData
{
    public static Dictionary<string, Dictionary<string, object>> ALL_STRUCTS = new Dictionary<string, Dictionary<string, object>>();
    public static Dictionary<string, Dictionary<string, object>> ALL_ENUMS = new Dictionary<string, Dictionary<string, object>>();
    
    static IdlData()
    {
        foreach (var kvp in checkoutIdl.ALL_STRUCTS) ALL_STRUCTS[kvp.Key] = kvp.Value;
        foreach (var kvp in checkoutIdl.ALL_ENUMS) ALL_ENUMS[kvp.Key] = kvp.Value;
    }
}

public abstract class CatalogService
{
    public abstract List<Product> listProducts();

    public abstract Product? getProduct(string productId);

}

public abstract class CartService
{
    public abstract Cart addToCart(AddToCartRequest request);

    public abstract Cart? getCart(string cartId);

    public abstract bool clearCart(string cartId);

}

public abstract class OrderService
{
    public abstract CheckoutResponse createOrder(CreateOrderRequest request);

    public abstract Order? getOrder(string orderId);

}

public class BarristerServer
{
    private Dictionary<string, object> _handlers = new Dictionary<string, object>();
    private WebApplication? _app;
    private ILogger<BarristerServer>? _logger;

    public BarristerServer(ILogger<BarristerServer>? logger = null)
    {
        _logger = logger;
    }

    public void Register<T>(string interfaceName, T implementation) where T : class
    {
        _handlers[interfaceName] = implementation!;
        _logger?.LogInformation("Registered handler for interface: {InterfaceName}", interfaceName);
    }

    public async Task RunAsync(string host = "localhost", int port = 8080)
    {
        var builder = WebApplication.CreateBuilder(new WebApplicationOptions
        {
            WebRootPath = null,
            Args = new[] { $"--urls=http://{host}:{port}" }
        });
        _app = builder.Build();
        // Get logger from app services if not already set
        if (_logger == null)
        {
            _logger = _app.Services.GetService<ILogger<BarristerServer>>();
        }

        _app.MapPost("/", async (HttpContext context) =>
        {
            await HandleRequest(context);
        });

        Console.WriteLine($"Barrister server listening on http://{host}:{port}");
        await _app.RunAsync();
    }

    private async Task HandleRequest(HttpContext context)
    {
        if (context.Request.Method != "POST")
        {
            context.Response.StatusCode = 405;
            await context.Response.WriteAsJsonAsync(new { error = "Method Not Allowed" });
            return;
        }

        JsonElement requestJson;
        try
        {
            requestJson = await JsonSerializer.DeserializeAsync<JsonElement>(context.Request.Body);
        }
        catch (Exception e)
        {
            await WriteErrorResponse(context, null, -32700, "Parse error", $"Invalid JSON: {e.Message}");
            return;
        }

        object? response;
        if (requestJson.ValueKind == JsonValueKind.Array)
        {
            // Batch request
            var responses = new List<object?>();
            foreach (var req in requestJson.EnumerateArray())
            {
                var reqDict = ConvertJsonElementToDict(req);
                var resp = await HandleSingleRequest(reqDict);
                if (resp != null) responses.Add(resp);
            }
            if (responses.Count == 0)
            {
                context.Response.StatusCode = 204;
            }
            else
            {
                await context.Response.WriteAsJsonAsync(responses);
            }
        }
        else
        {
            var reqDict = ConvertJsonElementToDict(requestJson);
            response = await HandleSingleRequest(reqDict);
            if (response == null)
            {
                context.Response.StatusCode = 204;
            }
            else
            {
                await context.Response.WriteAsJsonAsync(response);
            }
        }
    }

    private Dictionary<string, object?> ConvertJsonElementToDict(JsonElement element)
    {
        var dict = new Dictionary<string, object?>();
        foreach (var prop in element.EnumerateObject())
        {
            dict[prop.Name] = ConvertJsonElementValue(prop.Value);
        }
        return dict;
    }

    private string? ExtractStringValue(object? value)
    {
        if (value is string str)
            return str;
        if (value is JsonElement jsonElement && jsonElement.ValueKind == JsonValueKind.String)
            return jsonElement.GetString();
        return null;
    }

    private object? ConvertJsonElementValue(JsonElement element)
    {
        switch (element.ValueKind)
        {
            case JsonValueKind.String:
                return element.GetString();
            case JsonValueKind.Number:
                if (element.TryGetInt32(out var intVal))
                    return intVal;
                if (element.TryGetInt64(out var longVal))
                    return longVal;
                return element.GetDouble();
            case JsonValueKind.True:
                return true;
            case JsonValueKind.False:
                return false;
            case JsonValueKind.Null:
                return null;
            case JsonValueKind.Array:
                var list = new List<object?>();
                foreach (var item in element.EnumerateArray())
                {
                    list.Add(ConvertJsonElementValue(item));
                }
                return list;
            case JsonValueKind.Object:
                return ConvertJsonElementToDict(element);
            default:
                return element;
        }
    }

    private void ConvertEnumIntsToStrings(Dictionary<string, object?> dict, Dictionary<string, Dictionary<string, object>> allStructs, Dictionary<string, Dictionary<string, object>> allEnums)
    {
        foreach (var kvp in dict.ToList())
        {
            var key = kvp.Key;
            var value = kvp.Value;
            if (value is Dictionary<string, object?> nestedDict)
            {
                ConvertEnumIntsToStrings(nestedDict, allStructs, allEnums);
            }
            else if (value is System.Collections.IList list)
            {
                for (int i = 0; i < list.Count; i++)
                {
                    if (list[i] is Dictionary<string, object?> listDict)
                    {
                        ConvertEnumIntsToStrings(listDict, allStructs, allEnums);
                    }
                }
            }
            else if (value is int intVal)
            {
                // Check if this integer might be an enum value by trying all enum definitions
                foreach (var enumKvp in allEnums)
                {
                    var enumDef = enumKvp.Value;
                    if (enumDef.TryGetValue("values", out var valuesObj) && valuesObj is System.Collections.IList enumValues && intVal >= 0 && intVal < enumValues.Count)
                    {
                        var enumValue = enumValues[intVal];
                        if (enumValue is Dictionary<string, object> enumValueDict && enumValueDict.TryGetValue("name", out var nameObj))
                        {
                            dict[key] = nameObj?.ToString();
                            break;
                        }
                        else if (enumValue is string enumName)
                        {
                            dict[key] = enumName;
                            break;
                        }
                    }
                }
            }
        }
    }

    private async Task<Dictionary<string, object?>?> HandleSingleRequest(Dictionary<string, object?> requestJson)
    {
        // Validate JSON-RPC 2.0 structure
        if (!requestJson.TryGetValue("jsonrpc", out var jsonrpcObj))
        {
            _logger?.LogWarning("Missing jsonrpc field");
            return ErrorResponse(null, -32600, "Invalid Request", "jsonrpc field is required");
        }
        var jsonrpc = ExtractStringValue(jsonrpcObj);
        if (jsonrpc != "2.0")
        {
            _logger?.LogWarning("Invalid JSON-RPC version: {JsonRpc}", jsonrpc ?? "null");
            return ErrorResponse(null, -32600, "Invalid Request", "jsonrpc must be '2.0'");
        }

        if (!requestJson.TryGetValue("method", out var methodObj))
        {
            _logger?.LogWarning("Missing method field");
            return ErrorResponse(null, -32600, "Invalid Request", "method field is required");
        }
        var method = ExtractStringValue(methodObj);
        if (method == null)
        {
            _logger?.LogWarning("Invalid method in request: {Method}", methodObj?.ToString() ?? "null");
            return ErrorResponse(null, -32600, "Invalid Request", "method must be a string");
        }

        requestJson.TryGetValue("params", out var paramsObj);
        requestJson.TryGetValue("id", out var requestId);
        bool isNotification = !requestJson.ContainsKey("id");
        _logger?.LogInformation("Received request: method={Method}, id={RequestId}, isNotification={IsNotification}", method, requestId, isNotification);
        _logger?.LogDebug("Request params: {Params}", paramsObj != null ? JsonSerializer.Serialize(paramsObj) : "null");

        // Special case: barrister-idl method
        if (method == "barrister-idl")
        {
            _logger?.LogDebug("Handling barrister-idl request");
            try
            {
                var idlJson = await File.ReadAllTextAsync("idl.json");
                var idlDoc = JsonSerializer.Deserialize<object>(idlJson);
                if (isNotification) return null;
                return new Dictionary<string, object?>
                {
                    { "jsonrpc", "2.0" },
                    { "result", idlDoc },
                    { "id", requestId }
                };
            }
            catch (Exception e)
            {
                _logger?.LogError(e, "Failed to load IDL JSON");
                return ErrorResponse(requestId, -32603, "Internal error", $"Failed to load IDL JSON: {e.Message}");
            }
        }

        // Parse method name: interface.method
        var parts = method.Split('.', 2);
        if (parts.Length != 2)
        {
            _logger?.LogWarning("Invalid method format: {Method}", method);
            return ErrorResponse(requestId, -32601, "Method not found", $"Invalid method format: {method}");
        }

        var interfaceName = parts[0];
        var methodName = parts[1];
        _logger?.LogDebug("Parsed method: interface={InterfaceName}, method={MethodName}", interfaceName, methodName);

        // Find handler
        if (!_handlers.TryGetValue(interfaceName, out var handler))
        {
            _logger?.LogWarning("Interface not registered: {InterfaceName}", interfaceName);
            return ErrorResponse(requestId, -32601, "Method not found", $"Interface '{interfaceName}' not registered");
        }

        // Find method definition
        Dictionary<string, object>? methodDef = null;

        if (interfaceName == "CatalogService")
        {
            var interfaceMethods = new Dictionary<string, Dictionary<string, object>>
            {
                { "listProducts", new Dictionary<string, object>
                {
                    { "parameters", new List<Dictionary<string, object>>
                    {
                    }},
                    { "returnType", new Dictionary<string, object> { { "array", new Dictionary<string, object> { { "userDefined", "Product" } } } } },
                    { "returnOptional", false },
                }},
                { "getProduct", new Dictionary<string, object>
                {
                    { "parameters", new List<Dictionary<string, object>>
                    {
                        new Dictionary<string, object>
                        {
                            { "name", "productId" },
                            { "type", new Dictionary<string, object> { { "builtIn", "string" } } },
                        },
                    }},
                    { "returnType", new Dictionary<string, object> { { "userDefined", "Product" } } },
                    { "returnOptional", true },
                }},
            };
            methodDef = interfaceMethods.TryGetValue(methodName, out var def) ? def : null;
        }
        else if (interfaceName == "CartService")
        {
            var interfaceMethods = new Dictionary<string, Dictionary<string, object>>
            {
                { "addToCart", new Dictionary<string, object>
                {
                    { "parameters", new List<Dictionary<string, object>>
                    {
                        new Dictionary<string, object>
                        {
                            { "name", "request" },
                            { "type", new Dictionary<string, object> { { "userDefined", "AddToCartRequest" } } },
                        },
                    }},
                    { "returnType", new Dictionary<string, object> { { "userDefined", "Cart" } } },
                    { "returnOptional", false },
                }},
                { "getCart", new Dictionary<string, object>
                {
                    { "parameters", new List<Dictionary<string, object>>
                    {
                        new Dictionary<string, object>
                        {
                            { "name", "cartId" },
                            { "type", new Dictionary<string, object> { { "builtIn", "string" } } },
                        },
                    }},
                    { "returnType", new Dictionary<string, object> { { "userDefined", "Cart" } } },
                    { "returnOptional", true },
                }},
                { "clearCart", new Dictionary<string, object>
                {
                    { "parameters", new List<Dictionary<string, object>>
                    {
                        new Dictionary<string, object>
                        {
                            { "name", "cartId" },
                            { "type", new Dictionary<string, object> { { "builtIn", "string" } } },
                        },
                    }},
                    { "returnType", new Dictionary<string, object> { { "builtIn", "bool" } } },
                    { "returnOptional", false },
                }},
            };
            methodDef = interfaceMethods.TryGetValue(methodName, out var def) ? def : null;
        }
        else if (interfaceName == "OrderService")
        {
            var interfaceMethods = new Dictionary<string, Dictionary<string, object>>
            {
                { "createOrder", new Dictionary<string, object>
                {
                    { "parameters", new List<Dictionary<string, object>>
                    {
                        new Dictionary<string, object>
                        {
                            { "name", "request" },
                            { "type", new Dictionary<string, object> { { "userDefined", "CreateOrderRequest" } } },
                        },
                    }},
                    { "returnType", new Dictionary<string, object> { { "userDefined", "CheckoutResponse" } } },
                    { "returnOptional", false },
                }},
                { "getOrder", new Dictionary<string, object>
                {
                    { "parameters", new List<Dictionary<string, object>>
                    {
                        new Dictionary<string, object>
                        {
                            { "name", "orderId" },
                            { "type", new Dictionary<string, object> { { "builtIn", "string" } } },
                        },
                    }},
                    { "returnType", new Dictionary<string, object> { { "userDefined", "Order" } } },
                    { "returnOptional", true },
                }},
            };
            methodDef = interfaceMethods.TryGetValue(methodName, out var def) ? def : null;
        }

        if (methodDef == null)
        {
            _logger?.LogWarning("Method not found: {InterfaceName}.{MethodName}", interfaceName, methodName);
            return ErrorResponse(requestId, -32601, "Method not found", $"Method '{methodName}' not found in interface '{interfaceName}'");
        }

        // Validate params
        var paramsList = paramsObj as System.Collections.IList ?? new List<object>();
        var expectedParams = (methodDef["parameters"] as System.Collections.IList) ?? new List<object>();
        _logger?.LogDebug("Validating params: expected={ExpectedCount}, got={ActualCount}", expectedParams.Count, paramsList.Count);
        if (paramsList.Count != expectedParams.Count)
        {
            _logger?.LogWarning("Parameter count mismatch: expected={ExpectedCount}, got={ActualCount}", expectedParams.Count, paramsList.Count);
            return ErrorResponse(requestId, -32602, "Invalid params", $"Expected {expectedParams.Count} parameters, got {paramsList.Count}");
        }

        // Validate each param
        for (int i = 0; i < paramsList.Count; i++)
        {
            var paramValue = paramsList[i];
            var paramDef = (expectedParams[i] as Dictionary<string, object>)!;
            var paramName = paramDef.TryGetValue("name", out var name) ? name?.ToString() : $"parameter {i}";
            _logger?.LogDebug("Validating parameter {Index} ({ParamName})", i, paramName);
            try
            {
                var typeDef = (Dictionary<string, object>)paramDef["type"];
                // Convert enum objects/values to strings for validation
                object? valueToValidate = paramValue;
                if (typeDef.TryGetValue("userDefined", out var userTypeObj) && userTypeObj is string userType)
                {
                    var enumDef = Types.FindEnum(userType, IdlData.ALL_ENUMS);
                    if (enumDef != null && paramValue != null)
                    {
                        if (paramValue is System.Text.Json.JsonElement jsonElem)
                        {
                            // Handle JsonElement enum values (could be string or number)
                            if (jsonElem.ValueKind == System.Text.Json.JsonValueKind.String)
                            {
                                valueToValidate = jsonElem.GetString();
                            }
                            else if (jsonElem.ValueKind == System.Text.Json.JsonValueKind.Number && jsonElem.TryGetInt32(out var enumInt))
                            {
                                // Convert integer enum value to string by looking up in enum definition
                                if (enumDef.TryGetValue("values", out var valuesObj) && valuesObj is System.Collections.IList enumValues && enumInt >= 0 && enumInt < enumValues.Count)
                                {
                                    var enumValue = enumValues[enumInt];
                                    if (enumValue is Dictionary<string, object> enumValueDict && enumValueDict.TryGetValue("name", out var nameObj))
                                    {
                                        valueToValidate = nameObj?.ToString();
                                    }
                                    else if (enumValue is string enumName)
                                    {
                                        valueToValidate = enumName;
                                    }
                                    else
                                    {
                                        // Fallback: use the integer as string
                                        valueToValidate = enumInt.ToString();
                                    }
                                }
                                else
                                {
                                    // Enum definition structure doesn't match expected format, use integer as string
                                    valueToValidate = enumInt.ToString();
                                }
                            }
                        }
                        else if (paramValue is int enumIntVal)
                        {
                            // Convert integer enum value to string by looking up in enum definition
                            if (enumDef.TryGetValue("values", out var valuesObj) && valuesObj is System.Collections.IList enumValues && enumIntVal >= 0 && enumIntVal < enumValues.Count)
                            {
                                var enumValue = enumValues[enumIntVal];
                                if (enumValue is Dictionary<string, object> enumValueDict && enumValueDict.TryGetValue("name", out var nameObj))
                                {
                                    valueToValidate = nameObj?.ToString();
                                }
                                else if (enumValue is string enumName)
                                {
                                    valueToValidate = enumName;
                                }
                                else
                                {
                                    // Fallback: use the integer as string
                                    valueToValidate = enumIntVal.ToString();
                                }
                            }
                            else
                            {
                                // Enum definition structure doesn't match expected format, use integer as string
                                valueToValidate = enumIntVal.ToString();
                            }
                        }
                        else if (!(paramValue is string))
                        {
                            // Convert enum object to string representation
                            valueToValidate = paramValue.ToString();
                        }
                    }
                }
                Validation.ValidateType(valueToValidate, typeDef, IdlData.ALL_STRUCTS, IdlData.ALL_ENUMS, false);
            }
            catch (Exception e)
            {
                _logger?.LogError(e, "Parameter validation failed: parameter {Index} ({ParamName})", i, paramName);
                return ErrorResponse(requestId, -32602, "Invalid params", $"Parameter {i} ({paramName}) validation failed: {e.Message}");
            }
        }

        // Invoke handler using reflection
        object? result;
        try
        {
            _logger?.LogDebug("Invoking method {InterfaceName}.{MethodName}", interfaceName, methodName);
            var handlerType = handler.GetType();
            var methodInfo = handlerType.GetMethod(methodName);
            if (methodInfo == null)
            {
                _logger?.LogError("Method not found via reflection: {InterfaceName}.{MethodName}", interfaceName, methodName);
                return ErrorResponse(requestId, -32601, "Method not found", $"Method '{methodName}' not found on interface '{interfaceName}'");
            }
            // Deserialize parameters to expected types using method parameter types
            var paramInfos = methodInfo.GetParameters();
            var deserializedParams = new object[paramsList.Count];
            var jsonOptions = new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            };
            jsonOptions.Converters.Add(new JsonStringEnumConverter());
            for (int i = 0; i < paramsList.Count; i++)
            {
                var paramValue = paramsList[i];
                var paramType = paramInfos[i].ParameterType;
                _logger?.LogDebug("Deserializing parameter {Index} to type {ParamType}", i, paramType.Name);
                string paramJson;
                if (paramValue is System.Text.Json.JsonElement jsonElement)
                {
                    paramJson = jsonElement.GetRawText();
                }
                else
                {
                    paramJson = JsonSerializer.Serialize(paramValue);
                }
                deserializedParams[i] = JsonSerializer.Deserialize(paramJson, paramType, jsonOptions);
            }
            _logger?.LogDebug("Calling method {InterfaceName}.{MethodName} with {ParamCount} parameters", interfaceName, methodName, deserializedParams.Length);
            result = methodInfo.Invoke(handler, deserializedParams);
            if (result is Task task)
            {
                await task;
                var resultProperty = task.GetType().GetProperty("Result");
                result = resultProperty?.GetValue(task);
            }
            _logger?.LogDebug("Method {InterfaceName}.{MethodName} completed successfully", interfaceName, methodName);
        }
        catch (RPCError rpcErr)
        {
            _logger?.LogWarning("RPCError from {InterfaceName}.{MethodName}: {Code} - {Message}", interfaceName, methodName, rpcErr.Code, rpcErr.Message);
            return ErrorResponse(requestId, rpcErr.Code, rpcErr.Message, rpcErr.Data);
        }
        catch (Exception e)
        {
            _logger?.LogError(e, "Exception invoking {InterfaceName}.{MethodName}: {Message}", interfaceName, methodName, e.Message);
            return ErrorResponse(requestId, -32603, "Internal error", $"Exception: {e.Message}\nStackTrace: {e.StackTrace}");
        }

        // Validate response
        if (methodDef.TryGetValue("returnType", out var returnTypeObj) && returnTypeObj is Dictionary<string, object> returnType)
        {
            _logger?.LogDebug("Validating response for {InterfaceName}.{MethodName}", interfaceName, methodName);
            try
            {
                var returnOptional = methodDef.TryGetValue("returnOptional", out var opt) && opt is bool optBool && optBool;

                // If result is null and return is optional, skip validation
                if (result == null)
                {
                    if (returnOptional)
                    {
                        _logger?.LogDebug("Response is null and optional, skipping validation");
                    }
                    else
                    {
                        return ErrorResponse(requestId, -32603, "Internal error", "Response validation failed: result is null but return type is not optional");
                    }
                }
                else
                {
                    // Convert struct objects to dictionaries and enum objects to strings for validation
                    object? valueToValidate = result;

                    // Handle array return types (e.g., List<Product>)
                    if (returnType.TryGetValue("array", out var arrayTypeObj) && arrayTypeObj is Dictionary<string, object> arrayType)
                    {
                        if (result is System.Collections.IList resultList)
                        {
                            // Convert each item in the list to a dictionary for validation
                            var validatedList = new List<object?>();
                            foreach (var item in resultList)
                            {
                                if (item != null)
                                {
                                    var itemJson = JsonSerializer.Serialize(item);
                                    var itemElement = JsonSerializer.Deserialize<JsonElement>(itemJson);
                                    var itemDict = ConvertJsonElementToDict(itemElement);
                                    if (itemDict is Dictionary<string, object?> dict)
                                    {
                                        ConvertEnumIntsToStrings(dict, IdlData.ALL_STRUCTS, IdlData.ALL_ENUMS);
                                    }
                                    validatedList.Add(itemDict);
                                }
                                else
                                {
                                    validatedList.Add(null);
                                }
                            }
                            valueToValidate = validatedList;
                        }
                    }
                    // Handle single struct return types
                    else if (returnType.TryGetValue("userDefined", out var returnUserTypeObj) && returnUserTypeObj is string returnUserType)
                    {
                        var structDef = Types.FindStruct(returnUserType, IdlData.ALL_STRUCTS);
                        if (structDef != null && !(result is Dictionary<string, object?>))
                        {
                            // Serialize struct object to JSON, then convert JsonElement to dictionary with proper type conversion
                            var structResultJson = JsonSerializer.Serialize(result);
                            var structJsonElement = JsonSerializer.Deserialize<JsonElement>(structResultJson);
                            valueToValidate = ConvertJsonElementToDict(structJsonElement);
                            // Convert enum integers to strings for validation
                            if (valueToValidate is Dictionary<string, object?> structDict)
                            {
                                ConvertEnumIntsToStrings(structDict, IdlData.ALL_STRUCTS, IdlData.ALL_ENUMS);
                            }
                        }
                        else
                        {
                            var enumDef = Types.FindEnum(returnUserType, IdlData.ALL_ENUMS);
                            if (enumDef != null && !(result is string) && !(result is System.Text.Json.JsonElement))
                            {
                                // Convert enum object to string representation
                                valueToValidate = result.ToString();
                            }
                        }
                    }
                    Validation.ValidateType(valueToValidate, returnType, IdlData.ALL_STRUCTS, IdlData.ALL_ENUMS, returnOptional);
                    _logger?.LogDebug("Response validation passed for {InterfaceName}.{MethodName}", interfaceName, methodName);
                }
            }
            catch (Exception e)
            {
                _logger?.LogError(e, "Response validation failed for {InterfaceName}.{MethodName}", interfaceName, methodName);
                return ErrorResponse(requestId, -32603, "Internal error", $"Response validation failed: {e.Message}");
            }
        }

        // Return success response
        if (isNotification) return null;
        // Serialize result to JSON for proper response
        var resultJson = JsonSerializer.Serialize(result);
        return new Dictionary<string, object?>
        {
            { "jsonrpc", "2.0" },
            { "result", JsonSerializer.Deserialize<object>(resultJson) },
            { "id", requestId }
        };
    }

    private Dictionary<string, object?> ErrorResponse(object? requestId, int code, string message, object? data = null)
    {
        var error = new Dictionary<string, object?> { { "code", code }, { "message", message } };
        if (data != null) error["data"] = data;
        return new Dictionary<string, object?>
        {
            { "jsonrpc", "2.0" },
            { "error", error },
            { "id", requestId }
        };
    }

    private async Task WriteErrorResponse(HttpContext context, object? requestId, int code, string message, object? data = null)
    {
        await context.Response.WriteAsJsonAsync(ErrorResponse(requestId, code, message, data));
    }
}
