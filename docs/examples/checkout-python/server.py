# Generated by barrister - do not edit

import abc
import json
import os
import sys
from http.server import HTTPServer, BaseHTTPRequestHandler
from typing import Any, Dict, List, Optional
from pathlib import Path

from barrister2 import RPCError, validate_type
from checkout import ALL_STRUCTS as CHECKOUT_STRUCTS, ALL_ENUMS as CHECKOUT_ENUMS

# Merge ALL_STRUCTS and ALL_ENUMS from all namespaces
ALL_STRUCTS = {}
ALL_STRUCTS.update(CHECKOUT_STRUCTS)

ALL_ENUMS = {}
ALL_ENUMS.update(CHECKOUT_ENUMS)

class CatalogService(abc.ABC):

    @abc.abstractmethod
    def listProducts(self):
        pass

    @abc.abstractmethod
    def getProduct(self, productId):
        pass


class CartService(abc.ABC):

    @abc.abstractmethod
    def addToCart(self, request):
        pass

    @abc.abstractmethod
    def getCart(self, cartId):
        pass

    @abc.abstractmethod
    def clearCart(self, cartId):
        pass


class OrderService(abc.ABC):

    @abc.abstractmethod
    def createOrder(self, request):
        pass

    @abc.abstractmethod
    def getOrder(self, orderId):
        pass


class BarristerServer:
    """HTTP server for JSON-RPC 2.0 requests using Python's built-in http.server"""

    def __init__(self, host: str = 'localhost', port: int = 8080):
        self.host = host
        self.port = port
        self.handlers: Dict[str, Any] = {}
        self._server: Optional[HTTPServer] = None

    def register(self, interface_name: str, instance: Any) -> None:
        """Register an interface implementation instance"""
        self.handlers[interface_name] = instance

    def _create_handler_class(self):
        handlers = self.handlers
        server_instance = self

        class BarristerHandler(BaseHTTPRequestHandler):
            def do_POST(self):
                # Read request body
                content_length = int(self.headers.get('Content-Length', 0))
                if content_length == 0:
                    self._send_error_response(None, -32700, "Parse error", "Empty request body")
                    return

                body = self.rfile.read(content_length)
                
                try:
                    data = json.loads(body.decode('utf-8'))
                except (json.JSONDecodeError, UnicodeDecodeError) as e:
                    self._send_error_response(None, -32700, "Parse error", f"Invalid JSON: {e}")
                    return

                # Handle batch requests
                if isinstance(data, list):
                    if len(data) == 0:
                        self._send_error_response(None, -32600, "Invalid Request", "Empty batch array")
                        return
                    responses = []
                    for req in data:
                        response = server_instance.handle_request(req)
                        if response is not None:
                            responses.append(response)
                    if len(responses) == 0:
                        self._send_response(204, b'')
                    else:
                        self._send_json_response(200, responses)
                else:
                    response = server_instance.handle_request(data)
                    if response is None:
                        self._send_response(204, b'')
                    else:
                        self._send_json_response(200, response)

            def _send_json_response(self, status: int, data: Any) -> None:
                """Send a JSON response"""
                response_body = json.dumps(data).encode('utf-8')
                self.send_response(status)
                self.send_header('Content-Type', 'application/json')
                self.send_header('Content-Length', str(len(response_body)))
                self.end_headers()
                self.wfile.write(response_body)

            def _send_response(self, status: int, body: bytes) -> None:
                """Send a response with raw body"""
                self.send_response(status)
                if len(body) > 0:
                    self.send_header('Content-Length', str(len(body)))
                self.end_headers()
                if len(body) > 0:
                    self.wfile.write(body)

            def _send_error_response(self, request_id: Any, code: int, message: str, data: Any = None) -> None:
                """Send a JSON-RPC 2.0 error response"""
                error = {'code': code, 'message': message}
                if data is not None:
                    error['data'] = data
                response = {'jsonrpc': '2.0', 'error': error, 'id': request_id}
                self._send_json_response(200, response)

            def log_message(self, format: str, *args: Any) -> None:
                """Override to customize logging if needed"""
                # Suppress default logging, or customize as needed
                pass

        return BarristerHandler

    def handle_request(self, request_json: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Handle a single JSON-RPC 2.0 request"""
        # Validate JSON-RPC 2.0 structure
        if not isinstance(request_json, dict):
            return self._error_response(None, -32600, "Invalid Request", "Request must be an object")
        
        jsonrpc = request_json.get('jsonrpc')
        if jsonrpc != '2.0':
            return self._error_response(None, -32600, "Invalid Request", "jsonrpc must be '2.0'")
        
        method = request_json.get('method')
        if not isinstance(method, str):
            return self._error_response(None, -32600, "Invalid Request", "method must be a string")
        
        params = request_json.get('params')
        request_id = request_json.get('id')
        is_notification = 'id' not in request_json
        
        # Special case: barrister-idl method returns the IDL JSON document
        if method == "barrister-idl":
            try:
                # Get the directory where server.py is located
                server_dir = os.path.dirname(os.path.abspath(__file__))
                idl_json_path = os.path.join(server_dir, "idl.json")
                
                with open(idl_json_path, 'r', encoding='utf-8') as f:
                    idl_doc = json.load(f)
                
                # Return success response
                if is_notification:
                    return None
                return {
                    'jsonrpc': '2.0',
                    'result': idl_doc,
                    'id': request_id
                }
            except FileNotFoundError:
                return self._error_response(request_id, -32603, "Internal error", "IDL JSON file not found")
            except json.JSONDecodeError as e:
                return self._error_response(request_id, -32603, "Internal error", f"Failed to parse IDL JSON: {e}")
            except Exception as e:
                return self._error_response(request_id, -32603, "Internal error", f"Failed to load IDL JSON: {e}")
        
        # Parse method name: interface.method
        parts = method.split('.', 1)
        if len(parts) != 2:
            return self._error_response(request_id, -32601, "Method not found", f"Invalid method format: {method}")
        
        interface_name, method_name = parts
        
        # Find handler
        handler = self.handlers.get(interface_name)
        if handler is None:
            return self._error_response(request_id, -32601, "Method not found", f"Interface '{interface_name}' not registered")
        
        # Find method on handler
        if not hasattr(handler, method_name):
            return self._error_response(request_id, -32601, "Method not found", f"Method '{method_name}' not found on interface '{interface_name}'")
        
        method_func = getattr(handler, method_name)
        
        # Find interface and method definition
        method_def = None
        
        # Interface method lookup
        if interface_name == 'CatalogService':
            interface_methods = {
                'listProducts': {
                    'parameters': [
                    ],
                    'returnType': {'array': {'userDefined': 'Product'}},
                    'returnOptional': False,
                },
                'getProduct': {
                    'parameters': [
                        {
                            'name': 'productId',
                            'type': {'builtIn': 'string'},
                        },
                    ],
                    'returnType': {'userDefined': 'Product'},
                    'returnOptional': True,
                },
            }
            method_def = interface_methods.get(method_name)
        elif interface_name == 'CartService':
            interface_methods = {
                'addToCart': {
                    'parameters': [
                        {
                            'name': 'request',
                            'type': {'userDefined': 'AddToCartRequest'},
                        },
                    ],
                    'returnType': {'userDefined': 'Cart'},
                    'returnOptional': False,
                },
                'getCart': {
                    'parameters': [
                        {
                            'name': 'cartId',
                            'type': {'builtIn': 'string'},
                        },
                    ],
                    'returnType': {'userDefined': 'Cart'},
                    'returnOptional': True,
                },
                'clearCart': {
                    'parameters': [
                        {
                            'name': 'cartId',
                            'type': {'builtIn': 'string'},
                        },
                    ],
                    'returnType': {'builtIn': 'bool'},
                    'returnOptional': False,
                },
            }
            method_def = interface_methods.get(method_name)
        elif interface_name == 'OrderService':
            interface_methods = {
                'createOrder': {
                    'parameters': [
                        {
                            'name': 'request',
                            'type': {'userDefined': 'CreateOrderRequest'},
                        },
                    ],
                    'returnType': {'userDefined': 'CheckoutResponse'},
                    'returnOptional': False,
                },
                'getOrder': {
                    'parameters': [
                        {
                            'name': 'orderId',
                            'type': {'builtIn': 'string'},
                        },
                    ],
                    'returnType': {'userDefined': 'Order'},
                    'returnOptional': True,
                },
            }
            method_def = interface_methods.get(method_name)

        
        if method_def is None:
            return self._error_response(request_id, -32601, "Method not found", f"Method '{method_name}' not found in interface '{interface_name}'")
        
        # Validate params
        if params is None:
            params = []
        if not isinstance(params, list):
            return self._error_response(request_id, -32602, "Invalid params", "params must be an array")
        
        # Validate param count
        expected_params = method_def.get('parameters', [])
        if len(params) != len(expected_params):
            return self._error_response(request_id, -32602, "Invalid params", f"Expected {len(expected_params)} parameters, got {len(params)}")
        
        # Validate each param
        for i, (param_value, param_def) in enumerate(zip(params, expected_params)):
            try:
                validate_type(param_value, param_def['type'], ALL_STRUCTS, ALL_ENUMS, False)
            except Exception as e:
                return self._error_response(request_id, -32602, "Invalid params", f"Parameter {i} ({param_def['name']}) validation failed: {e}")
        
        # Invoke handler
        try:
            result = method_func(*params)
        except RPCError as e:
            return self._error_response(request_id, e.code, e.message, e.data)
        except Exception as e:
            return self._error_response(request_id, -32603, "Internal error", str(e))
        
        # Validate response
        return_type = method_def.get('returnType')
        return_optional = method_def.get('returnOptional', False)
        if return_type:
            try:
                validate_type(result, return_type, ALL_STRUCTS, ALL_ENUMS, return_optional)
            except Exception as e:
                return self._error_response(request_id, -32603, "Internal error", f"Response validation failed: {e}")
        
        # Return success response
        if is_notification:
            return None
        return {
            'jsonrpc': '2.0',
            'result': result,
            'id': request_id
        }

    def _error_response(self, request_id: Any, code: int, message: str, data: Any = None) -> Dict[str, Any]:
        """Create a JSON-RPC 2.0 error response"""
        error = {
            'code': code,
            'message': message
        }
        if data is not None:
            error['data'] = data
        return {
            'jsonrpc': '2.0',
            'error': error,
            'id': request_id
        }

    def serve_forever(self) -> None:
        """Start the HTTP server and serve forever"""
        handler_class = self._create_handler_class()
        self._server = HTTPServer((self.host, self.port), handler_class)
        print(f"Barrister server listening on http://{self.host}:{self.port}")
        self._server.serve_forever()

    def shutdown(self) -> None:
        """Shutdown the HTTP server"""
        if self._server:
            self._server.shutdown()
