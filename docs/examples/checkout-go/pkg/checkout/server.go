//go:build !client_only
// +build !client_only

// Generated by barrister - do not edit

package checkout

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"reflect"
	"strings"
)

// Merge ALL_STRUCTS and ALL_ENUMS from all namespaces
var ALL_STRUCTS = StructMap{}
var ALL_ENUMS = EnumMap{}

func init() {
	for k, v := range CHECKOUT_ALL_STRUCTS {
		ALL_STRUCTS[k] = v
	}
	for k, v := range CHECKOUT_ALL_ENUMS {
		ALL_ENUMS[k] = v
	}
}

type CatalogService interface {
	ListProducts() []Product
	GetProduct(productId string) *Product
}

type CartService interface {
	AddToCart(request AddToCartRequest) Cart
	GetCart(cartId string) *Cart
	ClearCart(cartId string) bool
}

type OrderService interface {
	CreateOrder(request CreateOrderRequest) CheckoutResponse
	GetOrder(orderId string) *Order
}

// BarristerServer is an HTTP server for JSON-RPC 2.0 requests
type BarristerServer struct {
	host     string
	port     int
	handlers map[string]interface{}
	server   *http.Server
}

// NewBarristerServer creates a new BarristerServer
func NewBarristerServer(host string, port int) *BarristerServer {
	return &BarristerServer{
		host:     host,
		port:     port,
		handlers: make(map[string]interface{}),
	}
}

// Register registers an interface implementation
func (s *BarristerServer) Register(interfaceName string, implementation interface{}) {
	s.handlers[interfaceName] = implementation
}

// ServeForever starts the HTTP server and serves forever
func (s *BarristerServer) ServeForever() error {
	mux := http.NewServeMux()
	mux.HandleFunc("/", s.handleRequest)
	addr := fmt.Sprintf("%s:%d", s.host, s.port)
	s.server = &http.Server{
		Addr:    addr,
		Handler: mux,
	}
	fmt.Printf("Barrister server listening on http://%s\n", addr)
	return s.server.ListenAndServe()
}

func (s *BarristerServer) handleRequest(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method Not Allowed", http.StatusMethodNotAllowed)
		return
	}

	body, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorResponse(w, nil, -32700, "Parse error", fmt.Sprintf("Failed to read body: %v", err))
		return
	}

	var requestData interface{}
	if err := json.Unmarshal(body, &requestData); err != nil {
		s.sendErrorResponse(w, nil, -32700, "Parse error", fmt.Sprintf("Invalid JSON: %v", err))
		return
	}

	// Handle batch requests
	if requests, ok := requestData.([]interface{}); ok {
		if len(requests) == 0 {
			s.sendErrorResponse(w, nil, -32600, "Invalid Request", "Empty batch array")
			return
		}
		var responses []interface{}
		for _, req := range requests {
			if reqMap, ok := req.(map[string]interface{}); ok {
				resp := s.handleSingleRequest(reqMap)
				if resp != nil {
					responses = append(responses, resp)
				}
			}
		}
		if len(responses) == 0 {
			w.WriteHeader(http.StatusNoContent)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(responses)
		return
	}

	// Handle single request
	if reqMap, ok := requestData.(map[string]interface{}); ok {
		response := s.handleSingleRequest(reqMap)
		if response == nil {
			w.WriteHeader(http.StatusNoContent)
			return
		}
		w.Header().Set("Content-Type", "application/json")
		json.NewEncoder(w).Encode(response)
	} else {
		s.sendErrorResponse(w, nil, -32600, "Invalid Request", "Request must be an object or array")
	}
}

func (s *BarristerServer) handleSingleRequest(requestJson map[string]interface{}) map[string]interface{} {
	// Validate JSON-RPC 2.0 structure
	jsonrpc, _ := requestJson["jsonrpc"].(string)
	if jsonrpc != "2.0" {
		return s.errorResponse(nil, -32600, "Invalid Request", "jsonrpc must be '2.0'")
	}

	method, ok := requestJson["method"].(string)
	if !ok {
		return s.errorResponse(nil, -32600, "Invalid Request", "method must be a string")
	}

	params, _ := requestJson["params"].([]interface{})
	requestID := requestJson["id"]
	_, isNotification := requestJson["id"]
	isNotification = !isNotification

	// Special case: barrister-idl method
	if method == "barrister-idl" {
		serverDir, _ := os.Getwd()
		idlJsonPath := filepath.Join(serverDir, "idl.json")
		idlData, err := os.ReadFile(idlJsonPath)
		if err != nil {
			return s.errorResponse(requestID, -32603, "Internal error", fmt.Sprintf("Failed to load IDL JSON: %v", err))
		}
		var idlDoc interface{}
		if err := json.Unmarshal(idlData, &idlDoc); err != nil {
			return s.errorResponse(requestID, -32603, "Internal error", fmt.Sprintf("Failed to parse IDL JSON: %v", err))
		}
		if isNotification {
			return nil
		}
		return map[string]interface{}{
			"jsonrpc": "2.0",
			"result": idlDoc,
			"id":     requestID,
		}
	}

	// Parse method name: interface.method
	parts := strings.Split(method, ".")
	if len(parts) != 2 {
		return s.errorResponse(requestID, -32601, "Method not found", fmt.Sprintf("Invalid method format: %s", method))
	}

	interfaceName := parts[0]
	methodName := parts[1]

	// Find handler
	handler, ok := s.handlers[interfaceName]
	if !ok {
		return s.errorResponse(requestID, -32601, "Method not found", fmt.Sprintf("Interface '%s' not registered", interfaceName))
	}

	// Find method definition
	var methodDef map[string]interface{}

	if interfaceName == "CatalogService" {
		interfaceMethods := map[string]map[string]interface{}{
			"listProducts": {
				"parameters": []interface{}{
				},
				"returnType": map[string]interface{}{"array": map[string]interface{}{"userDefined": "Product"}},
				"returnOptional": false,
			},
			"getProduct": {
				"parameters": []interface{}{
					map[string]interface{}{
						"name": "productId",
						"type": map[string]interface{}{"builtIn": "string"},
					},
				},
				"returnType": map[string]interface{}{"userDefined": "Product"},
				"returnOptional": true,
			},
		}
		methodDef = interfaceMethods[methodName]
	} else if interfaceName == "CartService" {
		interfaceMethods := map[string]map[string]interface{}{
			"addToCart": {
				"parameters": []interface{}{
					map[string]interface{}{
						"name": "request",
						"type": map[string]interface{}{"userDefined": "AddToCartRequest"},
					},
				},
				"returnType": map[string]interface{}{"userDefined": "Cart"},
				"returnOptional": false,
			},
			"getCart": {
				"parameters": []interface{}{
					map[string]interface{}{
						"name": "cartId",
						"type": map[string]interface{}{"builtIn": "string"},
					},
				},
				"returnType": map[string]interface{}{"userDefined": "Cart"},
				"returnOptional": true,
			},
			"clearCart": {
				"parameters": []interface{}{
					map[string]interface{}{
						"name": "cartId",
						"type": map[string]interface{}{"builtIn": "string"},
					},
				},
				"returnType": map[string]interface{}{"builtIn": "bool"},
				"returnOptional": false,
			},
		}
		methodDef = interfaceMethods[methodName]
	} else if interfaceName == "OrderService" {
		interfaceMethods := map[string]map[string]interface{}{
			"createOrder": {
				"parameters": []interface{}{
					map[string]interface{}{
						"name": "request",
						"type": map[string]interface{}{"userDefined": "CreateOrderRequest"},
					},
				},
				"returnType": map[string]interface{}{"userDefined": "CheckoutResponse"},
				"returnOptional": false,
			},
			"getOrder": {
				"parameters": []interface{}{
					map[string]interface{}{
						"name": "orderId",
						"type": map[string]interface{}{"builtIn": "string"},
					},
				},
				"returnType": map[string]interface{}{"userDefined": "Order"},
				"returnOptional": true,
			},
		}
		methodDef = interfaceMethods[methodName]
	}

	if methodDef == nil {
		return s.errorResponse(requestID, -32601, "Method not found", fmt.Sprintf("Method '%s' not found in interface '%s'", methodName, interfaceName))
	}

	// Validate params
	if params == nil {
		params = []interface{}{}
	}
	expectedParams, _ := methodDef["parameters"].([]interface{})
	if len(params) != len(expectedParams) {
		return s.errorResponse(requestID, -32602, "Invalid params", fmt.Sprintf("Expected %d parameters, got %d", len(expectedParams), len(params)))
	}

	// Validate each param
	for i, paramValue := range params {
		paramDef, _ := expectedParams[i].(map[string]interface{})
		paramType, _ := paramDef["type"].(map[string]interface{})
		if err := ValidateType(paramValue, paramType, ALL_STRUCTS, ALL_ENUMS, false); err != nil {
			paramName, _ := paramDef["name"].(string)
			return s.errorResponse(requestID, -32602, "Invalid params", fmt.Sprintf("Parameter %d (%s) validation failed: %v", i, paramName, err))
		}
	}

	// Invoke handler using reflection
	result, err := s.invokeHandler(handler, interfaceName, methodName, params)
	if err != nil {
		if rpcErr, ok := err.(*RPCError); ok {
			return s.errorResponse(requestID, rpcErr.Code, rpcErr.Message, rpcErr.Data)
		}
		return s.errorResponse(requestID, -32603, "Internal error", fmt.Sprintf("%v", err))
	}

	// Validate response
	returnType, _ := methodDef["returnType"].(map[string]interface{})
	returnOptional, _ := methodDef["returnOptional"].(bool)
	if returnType != nil {
		// Convert result to interface{} for validation
		var resultInterface interface{}
		if result != nil {
			// Marshal and unmarshal to convert to map[string]interface{}
			resultJSON, _ := json.Marshal(result)
			json.Unmarshal(resultJSON, &resultInterface)
		}
		if err := ValidateType(resultInterface, returnType, ALL_STRUCTS, ALL_ENUMS, returnOptional); err != nil {
			return s.errorResponse(requestID, -32603, "Internal error", fmt.Sprintf("Response validation failed: %v", err))
		}
	}

	// Return success response
	if isNotification {
		return nil
	}
	return map[string]interface{}{
		"jsonrpc": "2.0",
		"result": result,
		"id":     requestID,
	}
}

func (s *BarristerServer) sendErrorResponse(w http.ResponseWriter, requestID interface{}, code int, message string, data interface{}) {
	response := s.errorResponse(requestID, code, message, data)
	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(response)
}

func (s *BarristerServer) errorResponse(requestID interface{}, code int, message string, data interface{}) map[string]interface{} {
	error := map[string]interface{}{
		"code":    code,
		"message": message,
	}
	if data != nil {
		error["data"] = data
	}
	return map[string]interface{}{
		"jsonrpc": "2.0",
		"error":   error,
		"id":      requestID,
	}
}

func (s *BarristerServer) invokeHandler(handler interface{}, interfaceName, methodName string, params []interface{}) (interface{}, error) {
	// Convert params from JSON (interface{}) to typed values
	// This is a simplified approach - in practice, you'd unmarshal to the correct types
	
	// Use reflection to call methods dynamically
	handlerValue := reflect.ValueOf(handler)
	handlerType := handlerValue.Type()
	
	// Find method by name (Go methods are exported, convert snake_case to camelCase)
	methodNameCamel := ""
	if len(methodName) > 0 {
		parts := strings.Split(methodName, "_")
		for i, part := range parts {
			if i == 0 {
				methodNameCamel += strings.ToUpper(part[:1]) + part[1:]
			} else {
				methodNameCamel += strings.ToUpper(part[:1]) + part[1:]
			}
		}
	}
	
	// Try to find the method
	var method reflect.Method
	found := false
	for i := 0; i < handlerType.NumMethod(); i++ {
		m := handlerType.Method(i)
		if m.Name == methodNameCamel {
			method = m
			found = true
			break
		}
	}
	
	if !found {
		return nil, fmt.Errorf("method %s not found on interface %s", methodName, interfaceName)
	}
	
	// Convert params to the types expected by the method
	// This is simplified - in practice, you'd need to unmarshal JSON to the correct types
	methodType := method.Type
	numIn := methodType.NumIn()
	args := make([]reflect.Value, numIn-1) // -1 because first param is receiver
	
	for i := 1; i < numIn; i++ {
		paramType := methodType.In(i)
		paramValue := params[i-1]
		
		// Convert paramValue to paramType using JSON unmarshaling
		paramJSON, _ := json.Marshal(paramValue)
		paramPtr := reflect.New(paramType)
		if err := json.Unmarshal(paramJSON, paramPtr.Interface()); err != nil {
			return nil, fmt.Errorf("failed to convert parameter %d: %w", i-1, err)
		}
		args[i-1] = paramPtr.Elem()
	}
	
	// Call the method
	results := method.Func.Call(append([]reflect.Value{handlerValue}, args...))
	
	// Handle return values
	if len(results) == 0 {
		return nil, nil
	}
	if len(results) == 1 {
		if err, ok := results[0].Interface().(error); ok && err != nil {
			return nil, err
		}
		return results[0].Interface(), nil
	}
	// Multiple return values: result and error
	result := results[0].Interface()
	if err, ok := results[1].Interface().(error); ok && err != nil {
		return nil, err
	}
	return result, nil
}

