// Generated by barrister - do not edit

/// <reference types="node" />

import * as crypto from 'crypto';
import { RPCError } from './barrister2/rpc';
import { ALL_STRUCTS as CHECKOUT_STRUCTS, ALL_ENUMS as CHECKOUT_ENUMS } from './checkout';

import { validateType } from './barrister2/validation';

// Inline type definitions
interface TypeDef {
  builtIn?: string;
  array?: TypeDef;
  mapValue?: TypeDef;
  userDefined?: string;
}
interface StructDef {
  extends?: string;
  fields: Array<{ name: string; type: TypeDef; optional?: boolean }>;
}
interface EnumDef {
  values: Array<{ name: string }>;
}
type StructMap = { [key: string]: StructDef };
type EnumMap = { [key: string]: EnumDef };

// Merge ALL_STRUCTS and ALL_ENUMS from all namespaces
const ALL_STRUCTS: StructMap = {
  ...CHECKOUT_STRUCTS,
};

const ALL_ENUMS: EnumMap = {
  ...CHECKOUT_ENUMS,
};

export abstract class Transport {
  /**
   * Perform a JSON-RPC 2.0 call and return the response.
   * @param method The method name in format 'interface.method'
   * @param params List of parameters to pass to the method
   * @returns Promise that resolves to the JSON-RPC 2.0 response
   * @throws RPCError If the JSON-RPC call returns an error
   */
  abstract call(method: string, params: any[]): Promise<any>;
}

export class HTTPTransport extends Transport {
  private baseUrl: string;
  private headers: Record<string, string>;

  constructor(baseUrl: string, headers?: Record<string, string>) {
    super();
    this.baseUrl = baseUrl.replace(/\/$/, '');
    this.headers = headers ? { ...headers } : {};
  }

  async call(method: string, params: any[]): Promise<any> {
    // Generate request ID
    const requestId = crypto.randomUUID();

    // Build JSON-RPC 2.0 request
    const requestData = {
      jsonrpc: '2.0',
      method: method,
      params: params,
      id: requestId,
    };

    // Prepare fetch options
    const headers: Record<string, string> = {
      'Content-Type': 'application/json',
      ...this.headers,
    };

    try {
      // Send request using native fetch (Node.js 18+)
      const response = await fetch(this.baseUrl, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(requestData),
      });

      const responseBody = await response.text();
      let responseData: any;
      try {
        responseData = JSON.parse(responseBody);
      } catch (err) {
        throw new RPCError(-32700, 'Parse error', `Invalid JSON response: ${err}`);
      }

      // Check for JSON-RPC error
      if (responseData.error) {
        const error = responseData.error;
        const code = error.code || -32603;
        const message = error.message || 'Internal error';
        const data = error.data;
        throw new RPCError(code, message, data);
      }

      // Return response
      return responseData;
    } catch (err: any) {
      if (err instanceof RPCError) {
        throw err;
      }
      throw new RPCError(-32603, `Network error: ${err.message || String(err)}`, undefined);
    }
  }
}

export class CatalogServiceClient {
  private transport: Transport;
  private methodDefs: any;

  constructor(transport: Transport) {
    this.transport = transport;
    // Method definitions for validation
    this.methodDefs = {
      'listProducts': {
        parameters: [
        ],
        returnType: {array: {userDefined: 'Product'}},
        returnOptional: false,
      },
      'getProduct': {
        parameters: [
          {
            name: 'productId',
            type: {builtIn: 'string'},
          },
        ],
        returnType: {userDefined: 'Product'},
        returnOptional: true,
      },
    };
  }

  async listProducts(): Promise<any> {
    const methodDef = this.methodDefs['listProducts'];
    const params: any[] = [
    ];

    // Validate parameters
    const expectedParams = methodDef.parameters || [];
    for (let i = 0; i < params.length; i++) {
      try {
        validateType(params[i], expectedParams[i].type, ALL_STRUCTS, ALL_ENUMS, false);
      } catch (err: any) {
        throw new Error(`Parameter ${i} (${expectedParams[i].name}) validation failed: ${err.message}`);
      }
    }

    // Call transport
    const methodName = 'CatalogService.listProducts';
    const response = await this.transport.call(methodName, params);

    // Extract result from JSON-RPC response
    if (response.error) {
      const error = response.error;
      const code = error.code || -32603;
      const message = error.message || 'Internal error';
      const data = error.data;
      throw new RPCError(code, message, data);
    }

    const result = response.result;

    // Validate result
    const returnType = methodDef.returnType;
    const returnOptional = methodDef.returnOptional || false;
    if (returnType) {
      try {
        validateType(result, returnType, ALL_STRUCTS, ALL_ENUMS, returnOptional);
      } catch (err: any) {
        throw new Error(`Response validation failed: ${err.message}`);
      }
    }

    return result;
  }

  async getProduct(productId: any): Promise<any> {
    const methodDef = this.methodDefs['getProduct'];
    const params: any[] = [
      productId,
    ];

    // Validate parameters
    const expectedParams = methodDef.parameters || [];
    for (let i = 0; i < params.length; i++) {
      try {
        validateType(params[i], expectedParams[i].type, ALL_STRUCTS, ALL_ENUMS, false);
      } catch (err: any) {
        throw new Error(`Parameter ${i} (${expectedParams[i].name}) validation failed: ${err.message}`);
      }
    }

    // Call transport
    const methodName = 'CatalogService.getProduct';
    const response = await this.transport.call(methodName, params);

    // Extract result from JSON-RPC response
    if (response.error) {
      const error = response.error;
      const code = error.code || -32603;
      const message = error.message || 'Internal error';
      const data = error.data;
      throw new RPCError(code, message, data);
    }

    const result = response.result;

    // Validate result
    const returnType = methodDef.returnType;
    const returnOptional = methodDef.returnOptional || false;
    if (returnType) {
      try {
        validateType(result, returnType, ALL_STRUCTS, ALL_ENUMS, returnOptional);
      } catch (err: any) {
        throw new Error(`Response validation failed: ${err.message}`);
      }
    }

    return result;
  }

}

export class CartServiceClient {
  private transport: Transport;
  private methodDefs: any;

  constructor(transport: Transport) {
    this.transport = transport;
    // Method definitions for validation
    this.methodDefs = {
      'addToCart': {
        parameters: [
          {
            name: 'request',
            type: {userDefined: 'AddToCartRequest'},
          },
        ],
        returnType: {userDefined: 'Cart'},
        returnOptional: false,
      },
      'getCart': {
        parameters: [
          {
            name: 'cartId',
            type: {builtIn: 'string'},
          },
        ],
        returnType: {userDefined: 'Cart'},
        returnOptional: true,
      },
      'clearCart': {
        parameters: [
          {
            name: 'cartId',
            type: {builtIn: 'string'},
          },
        ],
        returnType: {builtIn: 'bool'},
        returnOptional: false,
      },
    };
  }

  async addToCart(request: any): Promise<any> {
    const methodDef = this.methodDefs['addToCart'];
    const params: any[] = [
      request,
    ];

    // Validate parameters
    const expectedParams = methodDef.parameters || [];
    for (let i = 0; i < params.length; i++) {
      try {
        validateType(params[i], expectedParams[i].type, ALL_STRUCTS, ALL_ENUMS, false);
      } catch (err: any) {
        throw new Error(`Parameter ${i} (${expectedParams[i].name}) validation failed: ${err.message}`);
      }
    }

    // Call transport
    const methodName = 'CartService.addToCart';
    const response = await this.transport.call(methodName, params);

    // Extract result from JSON-RPC response
    if (response.error) {
      const error = response.error;
      const code = error.code || -32603;
      const message = error.message || 'Internal error';
      const data = error.data;
      throw new RPCError(code, message, data);
    }

    const result = response.result;

    // Validate result
    const returnType = methodDef.returnType;
    const returnOptional = methodDef.returnOptional || false;
    if (returnType) {
      try {
        validateType(result, returnType, ALL_STRUCTS, ALL_ENUMS, returnOptional);
      } catch (err: any) {
        throw new Error(`Response validation failed: ${err.message}`);
      }
    }

    return result;
  }

  async getCart(cartId: any): Promise<any> {
    const methodDef = this.methodDefs['getCart'];
    const params: any[] = [
      cartId,
    ];

    // Validate parameters
    const expectedParams = methodDef.parameters || [];
    for (let i = 0; i < params.length; i++) {
      try {
        validateType(params[i], expectedParams[i].type, ALL_STRUCTS, ALL_ENUMS, false);
      } catch (err: any) {
        throw new Error(`Parameter ${i} (${expectedParams[i].name}) validation failed: ${err.message}`);
      }
    }

    // Call transport
    const methodName = 'CartService.getCart';
    const response = await this.transport.call(methodName, params);

    // Extract result from JSON-RPC response
    if (response.error) {
      const error = response.error;
      const code = error.code || -32603;
      const message = error.message || 'Internal error';
      const data = error.data;
      throw new RPCError(code, message, data);
    }

    const result = response.result;

    // Validate result
    const returnType = methodDef.returnType;
    const returnOptional = methodDef.returnOptional || false;
    if (returnType) {
      try {
        validateType(result, returnType, ALL_STRUCTS, ALL_ENUMS, returnOptional);
      } catch (err: any) {
        throw new Error(`Response validation failed: ${err.message}`);
      }
    }

    return result;
  }

  async clearCart(cartId: any): Promise<any> {
    const methodDef = this.methodDefs['clearCart'];
    const params: any[] = [
      cartId,
    ];

    // Validate parameters
    const expectedParams = methodDef.parameters || [];
    for (let i = 0; i < params.length; i++) {
      try {
        validateType(params[i], expectedParams[i].type, ALL_STRUCTS, ALL_ENUMS, false);
      } catch (err: any) {
        throw new Error(`Parameter ${i} (${expectedParams[i].name}) validation failed: ${err.message}`);
      }
    }

    // Call transport
    const methodName = 'CartService.clearCart';
    const response = await this.transport.call(methodName, params);

    // Extract result from JSON-RPC response
    if (response.error) {
      const error = response.error;
      const code = error.code || -32603;
      const message = error.message || 'Internal error';
      const data = error.data;
      throw new RPCError(code, message, data);
    }

    const result = response.result;

    // Validate result
    const returnType = methodDef.returnType;
    const returnOptional = methodDef.returnOptional || false;
    if (returnType) {
      try {
        validateType(result, returnType, ALL_STRUCTS, ALL_ENUMS, returnOptional);
      } catch (err: any) {
        throw new Error(`Response validation failed: ${err.message}`);
      }
    }

    return result;
  }

}

export class OrderServiceClient {
  private transport: Transport;
  private methodDefs: any;

  constructor(transport: Transport) {
    this.transport = transport;
    // Method definitions for validation
    this.methodDefs = {
      'createOrder': {
        parameters: [
          {
            name: 'request',
            type: {userDefined: 'CreateOrderRequest'},
          },
        ],
        returnType: {userDefined: 'CheckoutResponse'},
        returnOptional: false,
      },
      'getOrder': {
        parameters: [
          {
            name: 'orderId',
            type: {builtIn: 'string'},
          },
        ],
        returnType: {userDefined: 'Order'},
        returnOptional: true,
      },
    };
  }

  async createOrder(request: any): Promise<any> {
    const methodDef = this.methodDefs['createOrder'];
    const params: any[] = [
      request,
    ];

    // Validate parameters
    const expectedParams = methodDef.parameters || [];
    for (let i = 0; i < params.length; i++) {
      try {
        validateType(params[i], expectedParams[i].type, ALL_STRUCTS, ALL_ENUMS, false);
      } catch (err: any) {
        throw new Error(`Parameter ${i} (${expectedParams[i].name}) validation failed: ${err.message}`);
      }
    }

    // Call transport
    const methodName = 'OrderService.createOrder';
    const response = await this.transport.call(methodName, params);

    // Extract result from JSON-RPC response
    if (response.error) {
      const error = response.error;
      const code = error.code || -32603;
      const message = error.message || 'Internal error';
      const data = error.data;
      throw new RPCError(code, message, data);
    }

    const result = response.result;

    // Validate result
    const returnType = methodDef.returnType;
    const returnOptional = methodDef.returnOptional || false;
    if (returnType) {
      try {
        validateType(result, returnType, ALL_STRUCTS, ALL_ENUMS, returnOptional);
      } catch (err: any) {
        throw new Error(`Response validation failed: ${err.message}`);
      }
    }

    return result;
  }

  async getOrder(orderId: any): Promise<any> {
    const methodDef = this.methodDefs['getOrder'];
    const params: any[] = [
      orderId,
    ];

    // Validate parameters
    const expectedParams = methodDef.parameters || [];
    for (let i = 0; i < params.length; i++) {
      try {
        validateType(params[i], expectedParams[i].type, ALL_STRUCTS, ALL_ENUMS, false);
      } catch (err: any) {
        throw new Error(`Parameter ${i} (${expectedParams[i].name}) validation failed: ${err.message}`);
      }
    }

    // Call transport
    const methodName = 'OrderService.getOrder';
    const response = await this.transport.call(methodName, params);

    // Extract result from JSON-RPC response
    if (response.error) {
      const error = response.error;
      const code = error.code || -32603;
      const message = error.message || 'Internal error';
      const data = error.data;
      throw new RPCError(code, message, data);
    }

    const result = response.result;

    // Validate result
    const returnType = methodDef.returnType;
    const returnOptional = methodDef.returnOptional || false;
    if (returnType) {
      try {
        validateType(result, returnType, ALL_STRUCTS, ALL_ENUMS, returnOptional);
      } catch (err: any) {
        throw new Error(`Response validation failed: ${err.message}`);
      }
    }

    return result;
  }

}

