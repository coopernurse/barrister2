// Generated by barrister - do not edit

/// <reference types="node" />

import * as http from 'http';
import * as fs from 'fs';
import * as path from 'path';
import { RPCError } from './barrister2/rpc';
import { validateType } from './barrister2/validation';
import { ALL_STRUCTS as CHECKOUT_STRUCTS, ALL_ENUMS as CHECKOUT_ENUMS } from './checkout';

// Inline type definitions
interface TypeDef {
  builtIn?: string;
  array?: TypeDef;
  mapValue?: TypeDef;
  userDefined?: string;
}
interface StructDef {
  extends?: string;
  fields: Array<{ name: string; type: TypeDef; optional?: boolean }>;
}
interface EnumDef {
  values: Array<{ name: string }>;
}
type StructMap = { [key: string]: StructDef };
type EnumMap = { [key: string]: EnumDef };

// Merge ALL_STRUCTS and ALL_ENUMS from all namespaces
const ALL_STRUCTS: StructMap = {
  ...CHECKOUT_STRUCTS,
};

const ALL_ENUMS: EnumMap = {
  ...CHECKOUT_ENUMS,
};

export abstract class CatalogService {
  abstract listProducts(): any;
  abstract getProduct(productId: any): any;
}

export abstract class CartService {
  abstract addToCart(request: any): any;
  abstract getCart(cartId: any): any;
  abstract clearCart(cartId: any): any;
}

export abstract class OrderService {
  abstract createOrder(request: any): any;
  abstract getOrder(orderId: any): any;
}

export class BarristerServer {
  private host: string;
  private port: number;
  private handlers: Map<string, any>;
  private server: http.Server | null;

  constructor(host: string = 'localhost', port: number = 8080) {
    this.host = host;
    this.port = port;
    this.handlers = new Map();
    this.server = null;
  }

  register(interfaceName: string, instance: any): void {
    this.handlers.set(interfaceName, instance);
  }

  handleRequest(requestJson: any): any {
    // Validate JSON-RPC 2.0 structure
    if (typeof requestJson !== 'object' || requestJson === null || Array.isArray(requestJson)) {
      return this.errorResponse(null, -32600, 'Invalid Request', 'Request must be an object');
    }

    const jsonrpc = requestJson.jsonrpc;
    if (jsonrpc !== '2.0') {
      return this.errorResponse(null, -32600, 'Invalid Request', "jsonrpc must be '2.0'");
    }

    const method = requestJson.method;
    if (typeof method !== 'string') {
      return this.errorResponse(null, -32600, 'Invalid Request', 'method must be a string');
    }

    let params = requestJson.params;
    const requestId = requestJson.id;
    const isNotification = !('id' in requestJson);

    // Special case: barrister-idl method returns the IDL JSON document
    if (method === 'barrister-idl') {
      try {
        const serverDir = __dirname;
        const idlJsonPath = path.join(serverDir, 'idl.json');
        const idlDoc = JSON.parse(fs.readFileSync(idlJsonPath, 'utf-8'));

        if (isNotification) {
          return null;
        }
        return {
          jsonrpc: '2.0',
          result: idlDoc,
          id: requestId,
        };
      } catch (err: any) {
        return this.errorResponse(requestId, -32603, 'Internal error', `Failed to load IDL JSON: ${err.message}`);
      }
    }

    // Parse method name: interface.method
    const parts = method.split('.', 2);
    if (parts.length !== 2) {
      return this.errorResponse(requestId, -32601, 'Method not found', `Invalid method format: ${method}`);
    }

    const interfaceName = parts[0];
    const methodName = parts[1];

    // Find handler
    const handler = this.handlers.get(interfaceName);
    if (!handler) {
      return this.errorResponse(requestId, -32601, 'Method not found', `Interface '${interfaceName}' not registered`);
    }

    // Find method on handler
    if (typeof handler[methodName] !== 'function') {
      return this.errorResponse(requestId, -32601, 'Method not found', `Method '${methodName}' not found on interface '${interfaceName}'`);
    }

    const methodFunc = handler[methodName];

    // Find interface and method definition
    let methodDef: any = null;

    if (interfaceName === 'CatalogService') {
      const interfaceMethods: any = {
        'listProducts': {
          parameters: [
          ],
          returnType: {array: {userDefined: 'Product'}},
          returnOptional: false,
        },
        'getProduct': {
          parameters: [
            {
              name: 'productId',
              type: {builtIn: 'string'},
            },
          ],
          returnType: {userDefined: 'Product'},
          returnOptional: true,
        },
      };
      methodDef = interfaceMethods[methodName];
    } else if (interfaceName === 'CartService') {
      const interfaceMethods: any = {
        'addToCart': {
          parameters: [
            {
              name: 'request',
              type: {userDefined: 'AddToCartRequest'},
            },
          ],
          returnType: {userDefined: 'Cart'},
          returnOptional: false,
        },
        'getCart': {
          parameters: [
            {
              name: 'cartId',
              type: {builtIn: 'string'},
            },
          ],
          returnType: {userDefined: 'Cart'},
          returnOptional: true,
        },
        'clearCart': {
          parameters: [
            {
              name: 'cartId',
              type: {builtIn: 'string'},
            },
          ],
          returnType: {builtIn: 'bool'},
          returnOptional: false,
        },
      };
      methodDef = interfaceMethods[methodName];
    } else if (interfaceName === 'OrderService') {
      const interfaceMethods: any = {
        'createOrder': {
          parameters: [
            {
              name: 'request',
              type: {userDefined: 'CreateOrderRequest'},
            },
          ],
          returnType: {userDefined: 'CheckoutResponse'},
          returnOptional: false,
        },
        'getOrder': {
          parameters: [
            {
              name: 'orderId',
              type: {builtIn: 'string'},
            },
          ],
          returnType: {userDefined: 'Order'},
          returnOptional: true,
        },
      };
      methodDef = interfaceMethods[methodName];
    }

    if (!methodDef) {
      return this.errorResponse(requestId, -32601, 'Method not found', `Method '${methodName}' not found in interface '${interfaceName}'`);
    }

    // Validate params
    if (params === null || params === undefined) {
      params = [];
    }
    if (!Array.isArray(params)) {
      return this.errorResponse(requestId, -32602, 'Invalid params', 'params must be an array');
    }

    // Validate param count
    const expectedParams = methodDef.parameters || [];
    if (params.length !== expectedParams.length) {
      return this.errorResponse(requestId, -32602, 'Invalid params', `Expected ${expectedParams.length} parameters, got ${params.length}`);
    }

    // Validate each param
    for (let i = 0; i < params.length; i++) {
      try {
        validateType(params[i], expectedParams[i].type, ALL_STRUCTS, ALL_ENUMS, false);
      } catch (err: any) {
        return this.errorResponse(requestId, -32602, 'Invalid params', `Parameter ${i} (${expectedParams[i].name}) validation failed: ${err.message}`);
      }
    }

    // Invoke handler
    let result: any;
    try {
      result = methodFunc.apply(handler, params);
    } catch (err: any) {
      if (err instanceof RPCError) {
        return this.errorResponse(requestId, err.code, err.message, err.data);
      }
      return this.errorResponse(requestId, -32603, 'Internal error', err.message || String(err));
    }

    // Validate response
    const returnType = methodDef.returnType;
    const returnOptional = methodDef.returnOptional || false;
    if (returnType) {
      try {
        validateType(result, returnType, ALL_STRUCTS, ALL_ENUMS, returnOptional);
      } catch (err: any) {
        return this.errorResponse(requestId, -32603, 'Internal error', `Response validation failed: ${err.message}`);
      }
    }

    // Return success response
    if (isNotification) {
      return null;
    }
    return {
      jsonrpc: '2.0',
      result: result,
      id: requestId,
    };
  }

  private errorResponse(requestId: any, code: number, message: string, data?: any): any {
    const error: any = { code, message };
    if (data !== null && data !== undefined) {
      error.data = data;
    }
    return {
      jsonrpc: '2.0',
      error: error,
      id: requestId,
    };
  }

  serveForever(): void {
    this.server = http.createServer((req, res) => {
      if (req.method !== 'POST') {
        res.writeHead(405, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Method Not Allowed' }));
        return;
      }

      let body = '';
      req.on('data', (chunk) => { body += chunk.toString(); });
      req.on('end', () => {
        try {
          const data = JSON.parse(body);

          // Handle batch requests
          if (Array.isArray(data)) {
            if (data.length === 0) {
              res.writeHead(400, { 'Content-Type': 'application/json' });
              res.end(JSON.stringify({ error: 'Empty batch array' }));
              return;
            }
            const responses: any[] = [];
            for (const req of data) {
              const response = this.handleRequest(req);
              if (response !== null && response !== undefined) {
                responses.push(response);
              }
            }
            if (responses.length === 0) {
              res.writeHead(204);
              res.end();
            } else {
              res.writeHead(200, { 'Content-Type': 'application/json' });
              res.end(JSON.stringify(responses));
            }
          } else {
            const response = this.handleRequest(data);
            if (response === null || response === undefined) {
              res.writeHead(204);
              res.end();
            } else {
              res.writeHead(200, { 'Content-Type': 'application/json' });
              res.end(JSON.stringify(response));
            }
          }
        } catch (err: any) {
          const errorResponse = this.errorResponse(null, -32700, 'Parse error', err.message);
          res.writeHead(200, { 'Content-Type': 'application/json' });
          res.end(JSON.stringify(errorResponse));
        }
      });
    });

    this.server.listen(this.port, this.host, () => {
      console.log(`BarristerServer server listening on http://${this.host}:${this.port}`);
    });
  }

  shutdown(): void {
    if (this.server) {
      this.server.close();
      this.server = null;
    }
  }
}
