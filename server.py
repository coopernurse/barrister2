# Generated by barrister - do not edit

import abc
import json
from http.server import HTTPServer, BaseHTTPRequestHandler
from typing import Any, Dict, List, Optional

from barrister2 import RPCError, validate_type
from idl import ALL_STRUCTS, ALL_ENUMS

class UserService(abc.ABC):

    @abc.abstractmethod
    def createIfNew(self, userId, name):
        pass

    @abc.abstractmethod
    def get(self, userId):
        pass

    @abc.abstractmethod
    def update(self, user):
        pass


class BookService(abc.ABC):

    @abc.abstractmethod
    def put(self, book):
        pass

    @abc.abstractmethod
    def get(self, productId, userId):
        pass

    @abc.abstractmethod
    def delete(self, productIds):
        pass

    @abc.abstractmethod
    def cancelUserStatus(self, productId, userId):
        pass

    @abc.abstractmethod
    def setUserStatus(self, productId, userId, status):
        pass

    @abc.abstractmethod
    def getAvailable(self, platforms, userId, offset, limit):
        pass

    @abc.abstractmethod
    def getRecentActivity(self, limit):
        pass

    @abc.abstractmethod
    def getRecommendations(self, userId):
        pass

    @abc.abstractmethod
    def search(self, request):
        pass

    @abc.abstractmethod
    def getUserBooks(self, userId):
        pass

    @abc.abstractmethod
    def getUserTasks(self, userId):
        pass

    @abc.abstractmethod
    def ackLoan(self, userId, loanId, success):
        pass

    @abc.abstractmethod
    def bookNotLendable(self, productId, userId):
        pass

    @abc.abstractmethod
    def createLoan(self, productId, fromUserId, toUserId):
        pass


class CronJobs(abc.ABC):

    @abc.abstractmethod
    def refreshRecommendCache(self):
        pass

    @abc.abstractmethod
    def sendBooksAvailable(self):
        pass

    @abc.abstractmethod
    def sendBooksToLoan(self):
        pass

    @abc.abstractmethod
    def sendAvailableBookTweet(self):
        pass


class BarristerServer:
    """HTTP server for JSON-RPC 2.0 requests using Python's built-in http.server"""

    def __init__(self, host: str = 'localhost', port: int = 8080):
        self.host = host
        self.port = port
        self.handlers: Dict[str, Any] = {}
        self._server: Optional[HTTPServer] = None

    def register(self, interface_name: str, instance: Any) -> None:
        """Register an interface implementation instance"""
        self.handlers[interface_name] = instance

    def _create_handler_class(self):
        handlers = self.handlers
        server_instance = self

        class BarristerHandler(BaseHTTPRequestHandler):
            def do_POST(self):
                # Read request body
                content_length = int(self.headers.get('Content-Length', 0))
                if content_length == 0:
                    self._send_error_response(None, -32700, "Parse error", "Empty request body")
                    return

                body = self.rfile.read(content_length)
                
                try:
                    data = json.loads(body.decode('utf-8'))
                except (json.JSONDecodeError, UnicodeDecodeError) as e:
                    self._send_error_response(None, -32700, "Parse error", f"Invalid JSON: {e}")
                    return

                # Handle batch requests
                if isinstance(data, list):
                    if len(data) == 0:
                        self._send_error_response(None, -32600, "Invalid Request", "Empty batch array")
                        return
                    responses = []
                    for req in data:
                        response = server_instance.handle_request(req)
                        if response is not None:
                            responses.append(response)
                    if len(responses) == 0:
                        self._send_response(204, b'')
                    else:
                        self._send_json_response(200, responses)
                else:
                    response = server_instance.handle_request(data)
                    if response is None:
                        self._send_response(204, b'')
                    else:
                        self._send_json_response(200, response)

            def _send_json_response(self, status: int, data: Any) -> None:
                """Send a JSON response"""
                response_body = json.dumps(data).encode('utf-8')
                self.send_response(status)
                self.send_header('Content-Type', 'application/json')
                self.send_header('Content-Length', str(len(response_body)))
                self.end_headers()
                self.wfile.write(response_body)

            def _send_response(self, status: int, body: bytes) -> None:
                """Send a response with raw body"""
                self.send_response(status)
                if len(body) > 0:
                    self.send_header('Content-Length', str(len(body)))
                self.end_headers()
                if len(body) > 0:
                    self.wfile.write(body)

            def _send_error_response(self, request_id: Any, code: int, message: str, data: Any = None) -> None:
                """Send a JSON-RPC 2.0 error response"""
                error = {'code': code, 'message': message}
                if data is not None:
                    error['data'] = data
                response = {'jsonrpc': '2.0', 'error': error, 'id': request_id}
                self._send_json_response(200, response)

            def log_message(self, format: str, *args: Any) -> None:
                """Override to customize logging if needed"""
                # Suppress default logging, or customize as needed
                pass

        return BarristerHandler

    def handle_request(self, request_json: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """Handle a single JSON-RPC 2.0 request"""
        # Validate JSON-RPC 2.0 structure
        if not isinstance(request_json, dict):
            return self._error_response(None, -32600, "Invalid Request", "Request must be an object")
        
        jsonrpc = request_json.get('jsonrpc')
        if jsonrpc != '2.0':
            return self._error_response(None, -32600, "Invalid Request", "jsonrpc must be '2.0'")
        
        method = request_json.get('method')
        if not isinstance(method, str):
            return self._error_response(None, -32600, "Invalid Request", "method must be a string")
        
        params = request_json.get('params')
        request_id = request_json.get('id')
        is_notification = 'id' not in request_json
        
        # Parse method name: interface.method
        parts = method.split('.', 1)
        if len(parts) != 2:
            return self._error_response(request_id, -32601, "Method not found", f"Invalid method format: {method}")
        
        interface_name, method_name = parts
        
        # Find handler
        handler = self.handlers.get(interface_name)
        if handler is None:
            return self._error_response(request_id, -32601, "Method not found", f"Interface '{interface_name}' not registered")
        
        # Find method on handler
        if not hasattr(handler, method_name):
            return self._error_response(request_id, -32601, "Method not found", f"Method '{method_name}' not found on interface '{interface_name}'")
        
        method_func = getattr(handler, method_name)
        
        # Find interface and method definition
        method_def = None
        
        # Interface method lookup
        if interface_name == 'UserService':
            interface_methods = {
                'createIfNew': {
                    'parameters': [
                        {
                            'name': 'userId',
                            'type': {'builtIn': 'string'},
                        },
                        {
                            'name': 'name',
                            'type': {'builtIn': 'string'},
                        },
                    ],
                    'returnType': {'userDefined': 'BaseResponse'},
                    'returnOptional': False,
                },
                'get': {
                    'parameters': [
                        {
                            'name': 'userId',
                            'type': {'builtIn': 'string'},
                        },
                    ],
                    'returnType': {'userDefined': 'UserResponse'},
                    'returnOptional': False,
                },
                'update': {
                    'parameters': [
                        {
                            'name': 'user',
                            'type': {'userDefined': 'UserUpdate'},
                        },
                    ],
                    'returnType': {'userDefined': 'BaseResponse'},
                    'returnOptional': False,
                },
            }
            method_def = interface_methods.get(method_name)
        elif interface_name == 'BookService':
            interface_methods = {
                'put': {
                    'parameters': [
                        {
                            'name': 'book',
                            'type': {'userDefined': 'Book'},
                        },
                    ],
                    'returnType': {'userDefined': 'BaseResponse'},
                    'returnOptional': False,
                },
                'get': {
                    'parameters': [
                        {
                            'name': 'productId',
                            'type': {'builtIn': 'string'},
                        },
                        {
                            'name': 'userId',
                            'type': {'builtIn': 'string'},
                        },
                    ],
                    'returnType': {'userDefined': 'BookResponse'},
                    'returnOptional': False,
                },
                'delete': {
                    'parameters': [
                        {
                            'name': 'productIds',
                            'type': {'array': {'builtIn': 'string'}},
                        },
                    ],
                    'returnType': {'userDefined': 'DeleteResponse'},
                    'returnOptional': False,
                },
                'cancelUserStatus': {
                    'parameters': [
                        {
                            'name': 'productId',
                            'type': {'builtIn': 'string'},
                        },
                        {
                            'name': 'userId',
                            'type': {'builtIn': 'string'},
                        },
                    ],
                    'returnType': {'userDefined': 'BaseResponse'},
                    'returnOptional': False,
                },
                'setUserStatus': {
                    'parameters': [
                        {
                            'name': 'productId',
                            'type': {'builtIn': 'string'},
                        },
                        {
                            'name': 'userId',
                            'type': {'builtIn': 'string'},
                        },
                        {
                            'name': 'status',
                            'type': {'userDefined': 'BookUserStatus'},
                        },
                    ],
                    'returnType': {'userDefined': 'BaseResponse'},
                    'returnOptional': False,
                },
                'getAvailable': {
                    'parameters': [
                        {
                            'name': 'platforms',
                            'type': {'array': {'userDefined': 'Platform'}},
                        },
                        {
                            'name': 'userId',
                            'type': {'builtIn': 'string'},
                        },
                        {
                            'name': 'offset',
                            'type': {'builtIn': 'int'},
                        },
                        {
                            'name': 'limit',
                            'type': {'builtIn': 'int'},
                        },
                    ],
                    'returnType': {'userDefined': 'BooksResponse'},
                    'returnOptional': False,
                },
                'getRecentActivity': {
                    'parameters': [
                        {
                            'name': 'limit',
                            'type': {'builtIn': 'int'},
                        },
                    ],
                    'returnType': {'userDefined': 'ActivityResponse'},
                    'returnOptional': False,
                },
                'getRecommendations': {
                    'parameters': [
                        {
                            'name': 'userId',
                            'type': {'builtIn': 'string'},
                        },
                    ],
                    'returnType': {'userDefined': 'RecommendationsResponse'},
                    'returnOptional': False,
                },
                'search': {
                    'parameters': [
                        {
                            'name': 'request',
                            'type': {'userDefined': 'SearchRequest'},
                        },
                    ],
                    'returnType': {'userDefined': 'BooksResponse'},
                    'returnOptional': False,
                },
                'getUserBooks': {
                    'parameters': [
                        {
                            'name': 'userId',
                            'type': {'builtIn': 'string'},
                        },
                    ],
                    'returnType': {'userDefined': 'UserBooksResponse'},
                    'returnOptional': False,
                },
                'getUserTasks': {
                    'parameters': [
                        {
                            'name': 'userId',
                            'type': {'builtIn': 'string'},
                        },
                    ],
                    'returnType': {'userDefined': 'TasksResponse'},
                    'returnOptional': False,
                },
                'ackLoan': {
                    'parameters': [
                        {
                            'name': 'userId',
                            'type': {'builtIn': 'string'},
                        },
                        {
                            'name': 'loanId',
                            'type': {'builtIn': 'string'},
                        },
                        {
                            'name': 'success',
                            'type': {'builtIn': 'bool'},
                        },
                    ],
                    'returnType': {'userDefined': 'BaseResponse'},
                    'returnOptional': False,
                },
                'bookNotLendable': {
                    'parameters': [
                        {
                            'name': 'productId',
                            'type': {'builtIn': 'string'},
                        },
                        {
                            'name': 'userId',
                            'type': {'builtIn': 'string'},
                        },
                    ],
                    'returnType': {'userDefined': 'BaseResponse'},
                    'returnOptional': False,
                },
                'createLoan': {
                    'parameters': [
                        {
                            'name': 'productId',
                            'type': {'builtIn': 'string'},
                        },
                        {
                            'name': 'fromUserId',
                            'type': {'builtIn': 'string'},
                        },
                        {
                            'name': 'toUserId',
                            'type': {'builtIn': 'string'},
                        },
                    ],
                    'returnType': {'userDefined': 'LoanResponse'},
                    'returnOptional': False,
                },
            }
            method_def = interface_methods.get(method_name)
        elif interface_name == 'CronJobs':
            interface_methods = {
                'refreshRecommendCache': {
                    'parameters': [
                    ],
                    'returnType': {'userDefined': 'BaseResponse'},
                    'returnOptional': False,
                },
                'sendBooksAvailable': {
                    'parameters': [
                    ],
                    'returnType': {'userDefined': 'BaseResponse'},
                    'returnOptional': False,
                },
                'sendBooksToLoan': {
                    'parameters': [
                    ],
                    'returnType': {'userDefined': 'BaseResponse'},
                    'returnOptional': False,
                },
                'sendAvailableBookTweet': {
                    'parameters': [
                    ],
                    'returnType': {'userDefined': 'BaseResponse'},
                    'returnOptional': False,
                },
            }
            method_def = interface_methods.get(method_name)

        
        if method_def is None:
            return self._error_response(request_id, -32601, "Method not found", f"Method '{method_name}' not found in interface '{interface_name}'")
        
        # Validate params
        if params is None:
            params = []
        if not isinstance(params, list):
            return self._error_response(request_id, -32602, "Invalid params", "params must be an array")
        
        # Validate param count
        expected_params = method_def.get('parameters', [])
        if len(params) != len(expected_params):
            return self._error_response(request_id, -32602, "Invalid params", f"Expected {len(expected_params)} parameters, got {len(params)}")
        
        # Validate each param
        for i, (param_value, param_def) in enumerate(zip(params, expected_params)):
            try:
                validate_type(param_value, param_def['type'], ALL_STRUCTS, ALL_ENUMS, False)
            except Exception as e:
                return self._error_response(request_id, -32602, "Invalid params", f"Parameter {i} ({param_def['name']}) validation failed: {e}")
        
        # Invoke handler
        try:
            result = method_func(*params)
        except RPCError as e:
            return self._error_response(request_id, e.code, e.message, e.data)
        except Exception as e:
            return self._error_response(request_id, -32603, "Internal error", str(e))
        
        # Validate response
        return_type = method_def.get('returnType')
        return_optional = method_def.get('returnOptional', False)
        if return_type:
            try:
                validate_type(result, return_type, ALL_STRUCTS, ALL_ENUMS, return_optional)
            except Exception as e:
                return self._error_response(request_id, -32603, "Internal error", f"Response validation failed: {e}")
        
        # Return success response
        if is_notification:
            return None
        return {
            'jsonrpc': '2.0',
            'result': result,
            'id': request_id
        }

    def _error_response(self, request_id: Any, code: int, message: str, data: Any = None) -> Dict[str, Any]:
        """Create a JSON-RPC 2.0 error response"""
        error = {
            'code': code,
            'message': message
        }
        if data is not None:
            error['data'] = data
        return {
            'jsonrpc': '2.0',
            'error': error,
            'id': request_id
        }

    def serve_forever(self) -> None:
        """Start the HTTP server and serve forever"""
        handler_class = self._create_handler_class()
        self._server = HTTPServer((self.host, self.port), handler_class)
        print(f"Barrister server listening on http://{self.host}:{self.port}")
        self._server.serve_forever()

    def shutdown(self) -> None:
        """Shutdown the HTTP server"""
        if self._server:
            self._server.shutdown()
